# HG changeset patch
# User Fabian Groffen <grobian@gentoo.org>
# Date 1522498543 -7200
#      Sat Mar 31 14:15:43 2018 +0200
# Node ID b19cab9fe4ad0ffb03b67dd448c9068c234a4b1c
# Parent  dd070f9b9ecd33a007fbb5d9372b90c128b91f7f
notmuch patch by Karel Zak

Modified for Gentoo not to require strndup.

diff -r dd070f9b9ecd -r b19cab9fe4ad Makefile.am
--- a/Makefile.am	Sat Mar 31 14:15:41 2018 +0200
+++ b/Makefile.am	Sat Mar 31 14:15:43 2018 +0200
@@ -83,6 +83,16 @@ EXTRA_DIST = COPYRIGHT GPL OPS OPS.PGP O
 
 EXTRA_SCRIPTS = smime_keys
 
+if BUILD_NOTMUCH
+mutt_SOURCES += mutt_notmuch.c mutt_notmuch.h
+mutt_LDADD += $(NOTMUCH_LIBS)
+endif
+
+# kz
+EXTRA_DIST += UPDATING.kz README.notmuch OPS.NOTMUCH
+
+
+
 mutt_dotlock_SOURCES = mutt_dotlock.c
 mutt_dotlock_LDADD = $(LIBOBJS)
 mutt_dotlock_DEPENDENCIES = $(LIBOBJS)
@@ -135,9 +145,9 @@ smime_keys: $(srcdir)/smime_keys.pl
 keymap_defs.h: $(OPS) $(srcdir)/gen_defs
 	$(srcdir)/gen_defs $(OPS) > keymap_defs.h
 
-keymap_alldefs.h: $(srcdir)/OPS $(srcdir)/OPS.SIDEBAR $(srcdir)/OPS.PGP $(srcdir)/OPS.MIX $(srcdir)/OPS.CRYPT $(srcdir)/OPS.SMIME $(srcdir)/gen_defs
+keymap_alldefs.h: $(srcdir)/OPS $(srcdir)/OPS.SIDEBAR $(srcdir)/OPS.NOTMUCH $(srcdir)/OPS.PGP $(srcdir)/OPS.MIX $(srcdir)/OPS.CRYPT $(srcdir)/OPS.SMIME $(srcdir)/gen_defs
 	rm -f $@
-	$(srcdir)/gen_defs $(srcdir)/OPS $(srcdir)/OPS.SIDEBAR $(srcdir)/OPS.PGP \
+	$(srcdir)/gen_defs $(srcdir)/OPS $(srcdir)/OPS.SIDEBAR $(srcdir)/OPS.NOTMUCH $(srcdir)/OPS.PGP \
 		$(srcdir)/OPS.MIX $(srcdir)/OPS.CRYPT $(srcdir)/OPS.SMIME \
 			> keymap_alldefs.h
 
diff -r dd070f9b9ecd -r b19cab9fe4ad OPS.NOTMUCH
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/OPS.NOTMUCH	Sat Mar 31 14:15:43 2018 +0200
@@ -0,0 +1,5 @@
+OP_MAIN_CHANGE_VFOLDER "open a different virtual folder"
+OP_MAIN_VFOLDER_FROM_QUERY "generate virtual folder from query"
+OP_MAIN_MODIFY_LABELS "modify (notmuch) tags"
+OP_MAIN_MODIFY_LABELS_THEN_HIDE "modify labels and then hide message"
+OP_MAIN_ENTIRE_THREAD "read entire thread of the current message"
diff -r dd070f9b9ecd -r b19cab9fe4ad OPS.SIDEBAR
--- a/OPS.SIDEBAR	Sat Mar 31 14:15:41 2018 +0200
+++ b/OPS.SIDEBAR	Sat Mar 31 14:15:43 2018 +0200
@@ -5,4 +5,5 @@ OP_SIDEBAR_PAGE_DOWN "scroll the sidebar
 OP_SIDEBAR_PAGE_UP "scroll the sidebar up 1 page"
 OP_SIDEBAR_PREV "move the highlight to previous mailbox"
 OP_SIDEBAR_PREV_NEW "move the highlight to previous mailbox with new mail"
+OP_SIDEBAR_TOGGLE_VIRTUAL "toggle between mailboxes and virtual mailboxes"
 OP_SIDEBAR_TOGGLE_VISIBLE "make the sidebar (in)visible"
diff -r dd070f9b9ecd -r b19cab9fe4ad PATCHES
--- a/PATCHES	Sat Mar 31 14:15:41 2018 +0200
+++ b/PATCHES	Sat Mar 31 14:15:43 2018 +0200
@@ -1,3 +1,4 @@
+patch-notmuch-gentoo
 patch-nntp-vvv
 patch-limit-current-thread-neomutt
 patch-quasi-delete-neomutt
diff -r dd070f9b9ecd -r b19cab9fe4ad README.notmuch
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/README.notmuch	Sat Mar 31 14:15:43 2018 +0200
@@ -0,0 +1,403 @@
+notmuch support for mutt
+------------------------
+
+ * notmuch is e-mail fulltext indexing and tagging engine; see
+   http://notmuchmail.org/ for more information.
+
+ * home page (wiki) and git:
+
+   https://github.com/karelzak/mutt-kz
+
+   Note that the master branch is rebased to be up to date with mutt upstream. Use
+   stable/v<version> branches for downstream packaging.
+
+ * mailing list:
+
+   https://admin.fedoraproject.org/mailman/listinfo/mutt-kz
+
+ * requirements:
+
+   notmuch >= 0.9
+
+ * compile:
+
+  $ git clone git://github.com/karelzak/mutt-kz.git
+  $ cd mutt-kz
+  $ ./prepare
+  $ ./configure --enable-notmuch [--enable-debug]
+  $ make
+
+ * Folders URI
+
+   notmuch://[<path>][?<item>=<name>[& ...]]
+
+   The <path> is an absolute path to the directory where the notmuch database
+   is found as returned by 'notmuch config get database.path' command. Note that
+   the <path> should NOT include .notmuch directory name.
+
+   If the "<path>" is not defined then $nm_default_uri or $folder is used,
+   for example:
+
+	set nm_default_uri = "notmuch:///home/foo/maildir"
+	virtual-mailboxes "My INBOX" "notmuch://?query=tag:inbox"
+
+   Items:
+
+      query=<string>
+
+	 See SEARCH SYNTAX in notmuch man page. Don't forget to use "and" and
+         "or" operators in your queries.
+
+      Note that proper URI should not contain blank space and all "bad" chars
+      should be encoded, for example
+
+	 "tag:AAA and tag:BBB" --encoding-> tag:AAA%20and%20tag:BBB
+
+      but mutt config file parser is smart enough to accept space in quoted
+      strings. It means that you can use
+
+         "notmuch:///foo?query=tag:AAA and tag:BBB"
+
+      in your config files to keep things readable.
+
+      See http://xapian.org/docs/queryparser.html for more details about Xapian
+      queries.
+
+
+      limit=<number>
+
+         Restricts number of messages/threads in the result. The default limit
+         is nm_db_limit.
+
+      type=<threads|messages>
+
+         Reads all matching messages or whole-threads. The default is 'messages'
+         or nm_query_type.
+
+
+ * commands:
+
+   change-vfolder:
+      - switch to another virtual folder, a new folder maybe be specified by
+        vfolder description (see virtual-mailboxes) or URI
+      - the default is next vfolder with unread messages
+      - default key: X
+
+   vfolder-from-query:
+      - generate new virtual folder from notmuch search query
+      - default key: <Esc>X
+      - note: TAB completion of 'tag:' names is available
+
+   modify-labels:
+      - add or remove notmuch tags; [+]<tag> to add, -<tag> to remove
+      - default key: `
+      - note: TAB completion of tag names is available
+      - example: "+AAA +BBB -CCC"
+
+   modify-labels-then-hide:
+      - same as <modify-labels> but message is marked by <quasi-delete>
+      - not mapped to any key
+      - note: TAB completion of tag names is available
+      - example (add "archive" notmuch tag and remove message from screen):
+
+       macro index A "<modify-labels-then-hide>+archive -inbox\n<sync-mailbox>"
+       macro index I "<modify-labels-then-hide>-inbox\n<sync-mailbox>"
+
+   quasi-delete:
+      - delete message from mutt (usually after <sync-mailbox> function), but
+        don't touch message on disk
+
+   entire-thread:
+      - add to the current list of the messages all messages that belongs to the same thread
+        as the current message. This command is useful when you have a new email in your INBOX
+        and you want to see the rest of the archived thread.
+      - default key: +
+
+ * Pattern modifiers:
+
+   Many of Mutt's commands allow you to specify a pattern to match (limit,
+   tag-pattern, delete-pattern, color, etc.). The following notmuch specific
+   mutt pattern modifiers are available:
+
+   - '~Y EXPR': Messages which contain EXPR in the list of labels.
+     Example:
+        # Color red all messages labeled as 'spam'.
+        color index    red      default        "~Y '\W?spam\W?'"
+
+ * muttrc:
+
+   Note that you can use notmuch specific mutt config file, see -F <config> in
+   mutt docs.
+
+
+   virtual-mailboxes <description> <uri> [ ...]
+
+      This command specifies one or more virtual folder. The folders are
+      accessible by command 'X'. It's possible to use the virtual mailbox
+      description as a sort key (e.g set sort_sidebar=desc)
+
+      example:
+
+      virtual-mailboxes "Linux Kernel" "notmuch:///whereis/db?query=tag:lkml&limit=1000" \
+                        "Filesystems"  "notmuch:///whereis/db?query=tag:fs" \
+                        "Music"        "notmuch:///another/db?query=tag:hard and tag:heavy"
+
+      The folder description is used for status line, folders browser, sidebar
+      and <change-vfolder> command (this command also accepts vfolder URI). The
+      folder-hook regex uses the URI.
+
+   virtual_spoolfile = <boolean>
+
+      When set, mutt will use the first virtual mailbox (see virtual-mailboxes)
+      as a spoolfile.
+
+      When set together with sidebar, mutt will use list of virtual folders in
+      the sidebar. It's possible to toggle between virtual and normal folders by
+      sidebar-toggle command.
+
+   tag-transforms <tag> <transform> [ ...]
+
+      This command specifies text transforms to be shown instead of the actual
+      tag names with '%g' in the index and pager formats. Note that Unicode
+      symbols can be used for transforms.
+
+      example:
+
+      tag-transforms "inbox"   "i"   \
+                     "unread"  "u"   \
+                     "replied" "↻ "  \
+                     "sent"    "➥ "  \
+                     "todo"    "T"   \
+                     "deleted" "DEL" \
+                     "invites" "CAL"
+
+   tag-formats <tag> <format sequence> [ ...]
+
+      Specify index formatting sequences for individual tags for direct
+      placement in the $index_format. The formats must start with 'G' and
+      the entire sequence is case sensitive.
+
+      example:
+
+      tag-formats "inbox"   "GI" \
+                  "unread"  "GU" \
+                  "replied" "GR" \
+                  "sent"    "GS" \
+                  "todo"    "Gt" \
+                  "deleted" "GD" \
+                  "invites" "Gi"
+
+      Now instead of using '%g' in your $index_format, which lists all tags
+      in a non-deterministic order, you can something like the following which puts
+      a transformed tag name in a specific spot on the index line:
+
+      set index_format='4C %S %[%y.%m.%d] %-18.18n %?GU?%GU& ? %?GR?%GR& ? %?GI?%GI& ? %s'
+
+      The %G formatting sequence may display all tags including tags hidden by
+      nm_hidden_tags.
+
+   nm_record = <boolean>
+
+      Add messages stored to the mutt record (see $record in the mutt docs)
+      also to notmuch DB. If you reply to an email then the new email inherits
+      tags from the original email.
+
+   nm_record_tags = <comma delimited list>
+
+      Tags that should be removed or added to the to the messages stored in the mutt record.
+
+      example:
+
+      set record = "~/sent-mails"
+      set nm_record = yes
+      set nm_record_tags = "-inbox,archive,me"
+
+   nm_open_timeout = <seconds>
+
+      This option specifies timeout for Notmuch database. Default is 5 seconds.
+
+   nm_default_uri = <uri>
+
+      This variable specifies the default Notmuch database in format
+      notmuch://<absolute path>, the URI is used for notmuch queries (ESC+X) when the
+      current folder is not based on notmuch. If the default URI is not specified
+      then mutt will try to use $folder variable (see mutt manual for more details).
+
+   nm_hidden_tags = <comma delimited list>
+
+      This variable specifies private notmuch tags which should not be printed
+      on screen (index, pager).
+
+      Default is "unread,draft,flagged,passed,replied,attachment".
+
+   nm_exclude_tags = <comma delimited list>
+
+      The messages tagged with these tags are excluded and not loaded
+      from notmuch DB to mutt unless specified explicitly.
+
+      Not set by default.
+
+   nm_unread_tag = <name>
+
+      This variable specifies notmuch tag which is used for unread messages. The
+      variable is used to count unread messages in DB only. All other mutt
+      commands use standard (e.g. maildir) flags.
+
+      Default is "unread".
+
+   nm_db_limit = <num>
+
+     This variable specifies notmuch query limit.
+
+     Default is unlimited.
+
+   nm_query_type = <threads|messages>
+
+     This variable specifies notmuch query type, supported types: 'threads' and
+     'messages'.
+
+     Default is 'messages'.
+
+   vfolder_format = <string>
+
+      This variable allows you to customize the file browser display for virtual
+      folders to your personal taste.  This string is similar to $folder_format,
+
+	%C   current folder number
+	%f   folder name (description)
+	%m   number of messages in the mailbox *
+	%n   number of unread messages in the mailbox *
+	%N   N if mailbox has new mail, blank otherwise
+	%>X  right justify the rest of the string and pad with character ``X''
+	%|X  pad to the end of the line with character ``X''
+	%*X  soft-fill with character ``X'' as pad
+
+      Default is "%2C %?n?%4n/&     ?%4m %N %f"
+
+   index_format and pager_format
+
+        %g   notmuch tags (labels)
+        %Gx  specific notmuch tag defined by tag-formats (see above)
+
+        for example:
+
+        tag-formats "inbox" "GI"
+        set index_format = "%4C %Z %?GI?%GI? ?  %[%d/%b]  %-16.15F %s %> %?g?(%g)?"
+        set pager_format = "-%Z- %C/%m: %-20.20n   %s%*  -- %?g?(%g)? - (%P)"
+
+
+* .muttrc example:
+
+	set record="~/Mail/Maildir/sent-mail"
+	set nm_record = yes
+	set nm_record_tags ="-inbox me archive"
+
+	set nm_default_uri="notmuch:///home/kzak/Mail/Maildir"
+	set virtual_spoolfile	= yes
+	set sort_browser        = unsorted
+
+	# normal folders
+	set mbox_type=Maildir
+	set folder="~/Mail/Maildir"
+	mailboxes =rh =fedora =misc
+
+	set sidebar_width	 = 35
+	set sidebar_visible	 = yes
+	set sidebar_sort_method  = unsorted
+	set sidebar_divider_char = │
+
+	color sidebar_new yellow default
+	color progress default magenta
+
+	bind index <left> sidebar-prev
+	bind index <right> sidebar-next
+	bind index <space> sidebar-open
+	bind index <Esc>S sidebar-toggle-virtual
+
+	set index_format="%4C %Z %?GI?%GI& ? %[%d/%b]  %-16.15F %?M?(%3M)&     ? %s %> %?g?%g?"
+
+        # virtual folders
+	virtual-mailboxes \
+	   "INBOX"                "notmuch://?query=tag:inbox and NOT tag:archive" \
+	   "Util-linux"           "notmuch://?query=tag:ul and NOT tag:archive" \
+	   "Bugs"                 "notmuch://?query=tag:bug NOT tag:archive" \
+	   "RH"                   "notmuch://?query=tag:rh and NOT tag:archive" \
+	   "Fedora"               "notmuch://?query=tag:fed and NOT tag:archive" \
+	   "Linux"                "notmuch://?query=tag:lk and NOT tag:archive" \
+	   "NFS"                  "notmuch://?query=tag:nfs and NOT tag:archive" \
+	   "Filesystems"          "notmuch://?query=tag:fs and NOT tag:archive" \
+	   "Security"             "notmuch://?query=tag:sec" \
+	   "Partitioning"         "notmuch://?query=tag:part" \
+	   "GNU"                  "notmuch://?query=tag:gnu" \
+	   "udev"                 "notmuch://?query=tag:udev" \
+	   "initrd"               "notmuch://?query=tag:initrd" \
+	   "Linux CZ"             "notmuch://?query=tag:cz" \
+	   "Notmuch"              "notmuch://?query=tag:nm" \
+	   "Procps"               "notmuch://?query=tag:proc" \
+	\
+	   " Util-linux  [archive]" "notmuch://?query=tag:ul and tag:archive" \
+	   " Bugs        [archive]" "notmuch://?query=tag:bug and tag:archive" \
+	   " RH          [archive]" "notmuch://?query=tag:rh and tag:archive" \
+	   " Fedora      [archive]" "notmuch://?query=tag:fed and tag:archive" \
+	   " Linux       [archive]" "notmuch://?query=tag:lk and tag:archive" \
+	   " Filesystems [archive]" "notmuch://?query=tag:fs and tag:archive" \
+
+	# move message to archive
+	macro index A "<modify-labels-then-hide>+archive -inbox\n<sync-mailbox>"
+
+	# remove message from inbox
+	macro index I "<modify-labels-then-hide>-inbox\n<sync-mailbox>"
+
+	# mark emails for git-am
+	# (e.g. "git am -i -3 $(notmuch search --output=files tag:PATCH)"
+	#
+	macro index P "<modify-labels>PATCH\n"
+	macro index <Esc>P "<modify-labels>-PATCH\n"
+
+
+* .procmailrc example:
+
+	NOINBOX="-r inbox"
+
+	### Add 'kw' (keyword) tag to all interesting e-mails and make the emails
+	### visible in inbox.
+	:0
+	* ^Subject:.*(mount|umount|libmount|losetup|util-linux|blkid|hwclock|mkswap|fdisk|parted|partition|gpt|topology)
+	{
+		TAGS="-t kw"
+		NOINBOX=""
+	}
+
+	### Deliver emails to maildirs by notmuch-deliver
+	### from notmuch contrib/
+	###
+	###    notmuch-deliver -t <tags> [-t ...] <maildir>
+
+	:0:notmuch.lock
+	* ^List-Id:.*linux.linux.cz
+	| notmuch-deliver $NOINBOX -t cz $TAGS linux.cz
+
+	:0:notmuch.lock
+	* ^X-Mailing-List:.*util-linux@vger.kernel.org
+	| notmuch-deliver -t ul $TAGS util-linux
+
+	:0:notmuch.lock
+	* ^List-Id:.*parted-devel.lists.alioth.debian.org
+	| notmuch-deliver $NOINBOX -t part $TAGS parted
+
+	### [...cut to make the example short...] ###
+
+	### All unmatched mails
+	:0:notmuch.lock
+	* ^From
+	| notmuch-deliver $TAGS misc
+
+	### fallback if notmuch does not work
+	:0:
+	* ^From
+	Mail/Maildir/misc/
+
+
+* another example:
+
+  http://notmuchmail.org/mutttips/
diff -r dd070f9b9ecd -r b19cab9fe4ad UPDATING.kz
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/UPDATING.kz	Sat Mar 31 14:15:43 2018 +0200
@@ -0,0 +1,68 @@
+1.6.0.1:
+
++ rebase to mutt upstream 1.6.0
++ update to the new sidebar implementation. Note that all .muttrc options 
+  are prefixed by "sidebar_" now.
+
++ rebase is based on neomutt project (see https://github.com/neomutt) where are
+  maintained all non-upstream mutt changes, so it's easy to merge another
+  features like "trash", "ifdef", ... to mutt-kz.
+
++ the stable mutt-kz releases and tags are maintained in stable/v<version> branches, 
+  the master branch is going to be *rebased*. This development model help us to be 
+  up to date with mutt upstream.
+
+
+1.5.23.1:
+
++ integrated color status patch (original from Thomas Glanzmann)
+  https://thomas.glanzmann.de//mutt/#cstatus
++ integrated TLS Server Name Indication support patch (original from Phil Pennock)
++ improved sidebar functionality to optinaly show only folders with new emails
+  (sidebar-new, sitebar-next, ...)
+
++ fix notmuch DB usage
++ use unlocked libc IO in improve performance
++ security bug fix from original mutt
+
++ sync with the original mutt upstream
++ add sidebar_whitelist option
++ oppenc & pgp upstream sync and improvements
+
+
+1.5.22.1:
+
++ use git and github rather than hg to maintain source code
+
++ virtual folders based on notmuch queries
++ merge sidebar patch
++ merge index-color patch
+
++ <change-vfolder> command
++ <vfolder-from-query> command
++ <modify-labels> command to set/unset notmuch tags
++ <modify-labels-then-hide> command to set/unset notmuch tags and hide email
+  from the current view
++ <quasi-delete> command to delete message from mutt, but don't touch message
+  on the disk
++ <entire-thread> command to add to the current list of the messages all
+  messages that belongs to the same thread as the current message
++ ~Y EXPR  pattern modifier for notmuch labels for limit, tag-pattern,
+  delete-pattern, color etc.
++ virtual-mailboxes <desc> <uri> [...]  to specify list of the virtual mailboxes
++ virtual_spoolfile = <boolean> to use the first virtual mailbox as a spoolfile
++ tag-transforms <tag> <transform> to transform tag name to another name
++ tag-formats <tag> <format sequence> [ ...] to define tag specific formatting
+  sequence for $index_format
++ nm_record = <boolean> to add sent emails (mutt record) to notmuch DB
++ nm_record_tags = <comma delimited list> to specify tags for nm_record
++ nm_open_timeout = <seconds> to specify timeout for notmuch database
++ nm_default_uri = <uri>  the default URI to connect notmuch
++ nm_hidden_tags = <comma delimited list> to make some tags invisible for mutt user
++ nm_exclude_tags = <comma delimited list> - messages tagged with these tags
+  are excluded and not loaded from notmuch DB to mutt unless specified explicitly
++ nm_unread_tag = <name> to specify unread messages
++ nm_db_limit = <num> to specify notmuch query limit
++ nm_query_type = <threads|messages> to specify what to load from DB
++ vfolder_format = <string> to specify vfolders browser entry format
++ %g and %Gx index_format and pager_format formatting sequences
diff -r dd070f9b9ecd -r b19cab9fe4ad browser.c
--- a/browser.c	Sat Mar 31 14:15:41 2018 +0200
+++ b/browser.c	Sat Mar 31 14:15:43 2018 +0200
@@ -36,6 +36,9 @@
 #ifdef USE_NNTP
 #include "nntp.h"
 #endif
+#ifdef USE_NOTMUCH
+#include "mutt_notmuch.h"
+#endif
 
 #include <stdlib.h>
 #include <dirent.h>
@@ -260,6 +263,12 @@ folder_format_str (char *dest, size_t de
     case 'f':
     {
       char *s;
+
+#ifdef USE_NOTMUCH
+      if (mx_is_notmuch(folder->ff->name))
+        s = NONULL (folder->ff->desc);
+      else
+#endif
 #ifdef USE_IMAP
       if (folder->ff->imap)
 	s = NONULL (folder->ff->desc);
@@ -538,6 +547,8 @@ static void add_folder (MUTTMENU *m, str
     
     (state->entry)[state->entrylen].local = 1;
   }
+  else
+    (state->entry)[state->entrylen].local = 0;
 
   if (b)
   {
@@ -674,6 +685,32 @@ static int examine_directory (MUTTMENU *
   return 0;
 }
 
+#ifdef USE_NOTMUCH
+static int examine_vfolders (MUTTMENU *menu, struct browser_state *state)
+{
+  BUFFY *tmp = VirtIncoming;
+
+  if (!VirtIncoming)
+    return (-1);
+  mutt_buffy_check (0);
+
+  init_state (state, menu);
+
+  do
+  {
+    if (mx_is_notmuch (tmp->path))
+    {
+      nm_nonctx_get_count(tmp->path, &tmp->msg_count, &tmp->msg_unread);
+      add_folder (menu, state, tmp->path, tmp->desc, NULL, tmp, NULL);
+      continue;
+    }
+  }
+  while ((tmp = tmp->next));
+  browser_sort (state);
+  return 0;
+}
+#endif
+
 /* get list of mailboxes/subscribed newsgroups */
 static int examine_mailboxes (MUTTMENU *menu, struct browser_state *state)
 {
@@ -780,6 +817,13 @@ static int select_file_search (MUTTMENU 
   return (regexec (re, ((struct folder_file *) menu->data)[n].name, 0, NULL, 0));
 }
 
+#ifdef USE_NOTMUCH
+static int select_vfolder_search (MUTTMENU *menu, regex_t *re, int n)
+{
+  return (regexec (re, ((struct folder_file *) menu->data)[n].desc, 0, NULL, 0));
+}
+#endif
+
 static void folder_entry (char *s, size_t slen, MUTTMENU *menu, int num)
 {
   FOLDER folder;
@@ -797,6 +841,19 @@ static void folder_entry (char *s, size_
       (unsigned long) &folder, MUTT_FORMAT_ARROWCURSOR);
 }
 
+#ifdef USE_NOTMUCH
+static void vfolder_entry (char *s, size_t slen, MUTTMENU *menu, int num)
+{
+  FOLDER folder;
+
+  folder.ff = &((struct folder_file *) menu->data)[num];
+  folder.num = num;
+
+  mutt_FormatString (s, slen, 0, MuttIndexWindow->cols, NONULL(VirtFolderFormat), folder_format_str,
+      (unsigned long) &folder, MUTT_FORMAT_ARROWCURSOR);
+}
+#endif
+
 static void init_menu (struct browser_state *state, MUTTMENU *menu, char *title,
 		       size_t titlelen, int buffy)
 {
@@ -951,7 +1008,11 @@ void _mutt_select_file (char *f, size_t 
     }
 #endif
   }
+#ifdef USE_NOTMUCH
+  else if (!(flags & MUTT_SEL_VFOLDER))
+#else
   else 
+#endif
   {
     if (!folder)
       getcwd (LastDir, sizeof (LastDir));
@@ -979,6 +1040,12 @@ void _mutt_select_file (char *f, size_t 
 
   *f = 0;
 
+#ifdef USE_NOTMUCH
+  if (flags & MUTT_SEL_VFOLDER) {
+    if (examine_vfolders (NULL, &state) == -1)
+      goto bail;
+  } else
+#endif
   if (buffy)
   {
     if (examine_mailboxes (NULL, &state) == -1)
@@ -988,9 +1055,10 @@ void _mutt_select_file (char *f, size_t 
 #ifdef USE_IMAP
   if (!state.imap_browse)
 #endif
+  {
   if (examine_directory (NULL, &state, LastDir, prefix) == -1)
     goto bail;
-
+  }
   menu = mutt_new_menu (MENU_FOLDER);
   menu->make_entry = folder_entry;
   menu->search = select_file_search;
@@ -999,6 +1067,14 @@ void _mutt_select_file (char *f, size_t 
   if (multiple)
     menu->tag = file_tag;
 
+#ifdef USE_NOTMUCH
+  if (flags & MUTT_SEL_VFOLDER) {
+    menu->make_entry = vfolder_entry;
+    menu->search = select_vfolder_search;
+  } else
+#endif
+    menu->make_entry = folder_entry;
+
   menu->help = mutt_compile_help (helpstr, sizeof (helpstr), MENU_FOLDER,
 #ifdef USE_NNTP
     option (OPTNEWS) ? FolderNewsHelp :
@@ -1155,6 +1231,10 @@ void _mutt_select_file (char *f, size_t 
 	else if (state.imap_browse)
           strfcpy (f, state.entry[menu->current].name, flen);
 #endif
+#ifdef USE_NOTMUCH
+	else if (mx_is_notmuch(state.entry[menu->current].name))
+	  strfcpy (f, state.entry[menu->current].name, flen);
+#endif
 	else
 	  mutt_concat_path (f, LastDir, state.entry[menu->current].name, flen);
 
diff -r dd070f9b9ecd -r b19cab9fe4ad buffy.c
--- a/buffy.c	Sat Mar 31 14:15:41 2018 +0200
+++ b/buffy.c	Sat Mar 31 14:15:43 2018 +0200
@@ -37,6 +37,10 @@
 #include "imap.h"
 #endif
 
+#ifdef USE_NOTMUCH
+#include "mutt_notmuch.h"
+#endif
+
 #include <string.h>
 #include <sys/stat.h>
 #include <dirent.h>
@@ -218,6 +222,8 @@ static BUFFY *buffy_new (const char *pat
 
 static void buffy_free (BUFFY **mailbox)
 {
+  if (mailbox && *mailbox)
+    FREE (&(*mailbox)->desc);
   FREE (mailbox); /* __FREE_CHECKED__ */
 }
 
@@ -463,22 +469,171 @@ static int buffy_mbox_check (BUFFY* mail
   return rc;
 }
 
+#ifdef USE_NOTMUCH
+int mutt_parse_virtual_mailboxes (BUFFER *path, BUFFER *s, unsigned long data, BUFFER *err)
+{
+  BUFFY **tmp;
+  char buf[_POSIX_PATH_MAX + LONG_STRING + 32];   /* path to DB + query + URI "decoration" */
+
+  while (MoreArgs (s))
+  {
+    char *desc;
+
+    mutt_extract_token (path, s, 0);
+    if (path->data && *path->data)
+      desc = safe_strdup( path->data);
+    else
+      continue;
+
+    mutt_extract_token (path, s, 0);
+    strfcpy (buf, path->data, sizeof (buf));
+
+    /* Skip empty tokens. */
+    if(!*buf) {
+	    FREE(&desc);
+	    continue;
+    }
+
+    /* avoid duplicates */
+    for (tmp = &VirtIncoming; *tmp; tmp = &((*tmp)->next))
+    {
+      if (mutt_strcmp (buf, (*tmp)->path) == 0)
+      {
+	dprint(3,(debugfile,"virtual mailbox '%s' already registered as '%s'\n", buf, (*tmp)->path));
+	break;
+      }
+    }
+
+    if (!*tmp)
+      *tmp = buffy_new (buf);
+
+    (*tmp)->new = 0;
+    (*tmp)->notified = 1;
+    (*tmp)->newly_created = 0;
+    (*tmp)->size = 0;
+    (*tmp)->desc = desc;
+  }
+  return 0;
+}
+#endif
+
+static void buffy_check (BUFFY *tmp, struct stat *contex_sb, int check_stats)
+{
+    struct stat sb;
+#ifdef USE_SIDEBAR
+    short orig_new;
+    int orig_count;
+	int orig_unread;
+	int orig_flagged;
+#endif
+
+    sb.st_size=0;
+
+#ifdef USE_SIDEBAR
+    orig_new = tmp->new;
+    orig_count = tmp->msg_count;
+    orig_unread = tmp->msg_unread;
+    orig_flagged = tmp->msg_flagged;
+#endif
+
+    if (tmp->magic != MUTT_IMAP)
+    {
+      tmp->new = 0;
+#ifdef USE_POP
+      if (mx_is_pop (tmp->path))
+	tmp->magic = MUTT_POP;
+      else
+#endif
+#ifdef USE_NNTP
+      if ((tmp->magic == MUTT_NNTP) || mx_is_nntp (tmp->path))
+	tmp->magic = MUTT_NNTP;
+      else
+#endif
+#ifdef USE_NOTMUCH
+      if (mx_is_notmuch (tmp->path))
+	tmp->magic = MUTT_NOTMUCH;
+      else
+#endif
+      if (stat (tmp->path, &sb) != 0 || (S_ISREG(sb.st_mode) && sb.st_size == 0) ||
+	  (!tmp->magic && (tmp->magic = mx_get_magic (tmp->path)) <= 0))
+      {
+	/* if the mailbox still doesn't exist, set the newly created flag to
+	 * be ready for when it does. */
+	tmp->newly_created = 1;
+	tmp->magic = 0;
+	tmp->size = 0;
+	return;
+      }
+    }
+
+    /* check to see if the folder is the currently selected folder
+     * before polling */
+    if (!Context || !Context->path ||
+#ifdef USE_NNTP
+	(( tmp->magic == MUTT_IMAP || tmp->magic == MUTT_POP || tmp->magic == MUTT_NNTP )
+#else
+	(( tmp->magic == MUTT_IMAP || tmp->magic == MUTT_POP || tmp->magic == MUTT_NOTMUCH)
+#endif
+	    ? mutt_strcmp (tmp->path, Context->path) :
+	      (sb.st_dev != contex_sb->st_dev || sb.st_ino != contex_sb->st_ino)))
+    {
+      switch (tmp->magic)
+      {
+        case MUTT_MBOX:
+        case MUTT_MMDF:
+          if (buffy_mbox_check (tmp, &sb, check_stats) > 0)
+            BuffyCount++;
+          break;
+
+        case MUTT_MAILDIR:
+          if (buffy_maildir_check (tmp, check_stats) > 0)
+            BuffyCount++;
+          break;
+
+        case MUTT_MH:
+          if (mh_buffy (tmp, check_stats) > 0)
+            BuffyCount++;
+          break;
+#ifdef USE_NOTMUCH
+        case MUTT_NOTMUCH:
+          tmp->msg_count = 0;
+          tmp->msg_unread = 0;
+          tmp->msg_flagged = 0;
+          nm_nonctx_get_count(tmp->path, &tmp->msg_count, &tmp->msg_unread);
+          if (tmp->msg_unread > 0) {
+            BuffyCount++;
+            tmp->new = 1;
+          }
+          break;
+#endif
+      }
+    }
+    else if (option(OPTCHECKMBOXSIZE) && Context && Context->path)
+      tmp->size = (off_t) sb.st_size;	/* update the size of current folder */
+
+#ifdef USE_SIDEBAR
+    if ((orig_new != tmp->new) ||
+        (orig_count != tmp->msg_count) ||
+        (orig_unread != tmp->msg_unread) ||
+        (orig_flagged != tmp->msg_flagged))
+      mutt_set_current_menu_redraw (REDRAW_SIDEBAR);
+#endif
+
+    if (!tmp->new)
+      tmp->notified = 0;
+    else if (!tmp->notified)
+      BuffyNotify++;
+}
+
 /* Check all Incoming for new mail and total/new/flagged messages
  * force: if true, ignore BuffyTimeout and check for new mail anyway
  */
 int mutt_buffy_check (int force)
 {
   BUFFY *tmp;
-  struct stat sb;
   struct stat contex_sb;
   time_t t;
   int check_stats = 0;
-#ifdef USE_SIDEBAR
-  short orig_new;
-  int orig_count, orig_unread, orig_flagged;
-#endif
-
-  sb.st_size=0;
   contex_sb.st_dev=0;
   contex_sb.st_ino=0;
 
@@ -489,8 +644,13 @@ int mutt_buffy_check (int force)
 #endif
 
   /* fastest return if there are no mailboxes */
+#ifdef USE_NOTMUCH
+  if (!Incoming && !VirtIncoming)
+    return 0;
+#else
   if (!Incoming)
     return 0;
+#endif
   t = time (NULL);
   if (!force && (t - BuffyTime < BuffyTimeout))
     return BuffyCount;
@@ -522,85 +682,12 @@ int mutt_buffy_check (int force)
   }
   
   for (tmp = Incoming; tmp; tmp = tmp->next)
-  {
-#ifdef USE_SIDEBAR
-    orig_new = tmp->new;
-    orig_count = tmp->msg_count;
-    orig_unread = tmp->msg_unread;
-    orig_flagged = tmp->msg_flagged;
-#endif
-
-    if (tmp->magic != MUTT_IMAP)
-    {
-      tmp->new = 0;
-#ifdef USE_POP
-      if (mx_is_pop (tmp->path))
-	tmp->magic = MUTT_POP;
-      else
-#endif
-#ifdef USE_NNTP
-      if ((tmp->magic == MUTT_NNTP) || mx_is_nntp (tmp->path))
-	tmp->magic = MUTT_NNTP;
-      else
+    buffy_check(tmp, &contex_sb, check_stats);
+ 
+#ifdef USE_NOTMUCH
+  for (tmp = VirtIncoming; tmp; tmp = tmp->next)
+    buffy_check(tmp, &contex_sb, check_stats);
 #endif
-      if (stat (tmp->path, &sb) != 0 || (S_ISREG(sb.st_mode) && sb.st_size == 0) ||
-	  (!tmp->magic && (tmp->magic = mx_get_magic (tmp->path)) <= 0))
-      {
-	/* if the mailbox still doesn't exist, set the newly created flag to
-	 * be ready for when it does. */
-	tmp->newly_created = 1;
-	tmp->magic = 0;
-	tmp->size = 0;
-	continue;
-      }
-    }
-
-    /* check to see if the folder is the currently selected folder
-     * before polling */
-    if (!Context || !Context->path ||
-#ifdef USE_NNTP
-	(( tmp->magic == MUTT_IMAP || tmp->magic == MUTT_POP || tmp->magic == MUTT_NNTP )
-#else
-	(( tmp->magic == MUTT_IMAP || tmp->magic == MUTT_POP )
-#endif
-	    ? mutt_strcmp (tmp->path, Context->path) :
-	      (sb.st_dev != contex_sb.st_dev || sb.st_ino != contex_sb.st_ino)))
-    {
-      switch (tmp->magic)
-      {
-        case MUTT_MBOX:
-        case MUTT_MMDF:
-          if (buffy_mbox_check (tmp, &sb, check_stats) > 0)
-            BuffyCount++;
-          break;
-
-        case MUTT_MAILDIR:
-          if (buffy_maildir_check (tmp, check_stats) > 0)
-            BuffyCount++;
-          break;
-
-        case MUTT_MH:
-          if (mh_buffy (tmp, check_stats) > 0)
-            BuffyCount++;
-          break;
-      }
-    }
-    else if (option(OPTCHECKMBOXSIZE) && Context && Context->path)
-      tmp->size = (off_t) sb.st_size;	/* update the size of current folder */
-
-#ifdef USE_SIDEBAR
-    if ((orig_new != tmp->new) ||
-        (orig_count != tmp->msg_count) ||
-        (orig_unread != tmp->msg_unread) ||
-        (orig_flagged != tmp->msg_flagged))
-      mutt_set_current_menu_redraw (REDRAW_SIDEBAR);
-#endif
-
-    if (!tmp->new)
-      tmp->notified = 0;
-    else if (!tmp->notified)
-      BuffyNotify++;
-  }
 
   BuffyDoneTime = BuffyTime;
   return (BuffyCount);
@@ -717,6 +804,35 @@ void mutt_buffy (char *s, size_t slen)
   *s = '\0';
 }
 
+#ifdef USE_NOTMUCH
+void mutt_buffy_vfolder (char *s, size_t slen)
+{
+  BUFFY *tmp;
+  int pass, found = 0;
+
+  if (mutt_buffy_check (0))
+  {
+    for (pass = 0; pass < 2; pass++) {
+      for (tmp = VirtIncoming; tmp; tmp = tmp->next)
+      {
+	if ((found || pass) && tmp->new)
+	{
+	  strfcpy (s, tmp->desc, slen);
+	  return;
+	}
+	if (mutt_strcmp (s, tmp->path) == 0)
+	  found = 1;
+      }
+    }
+
+    mutt_buffy_check (1); /* buffy was wrong - resync things */
+  }
+
+  /* no folders with new mail */
+  *s = '\0';
+}
+#endif
+
 /* fetch buffy object for given path, if present */
 static BUFFY* buffy_get (const char *path)
 {
diff -r dd070f9b9ecd -r b19cab9fe4ad buffy.h
--- a/buffy.h	Sat Mar 31 14:15:41 2018 +0200
+++ b/buffy.h	Sat Mar 31 14:15:43 2018 +0200
@@ -28,6 +28,7 @@ typedef struct buffy_t
   char path[_POSIX_PATH_MAX];
   char realpath[_POSIX_PATH_MAX]; /* used for duplicate detection, context comparison,
                                      and the sidebar */
+  char *desc;
   off_t size;
   struct buffy_t *next;
   short new;			/* mailbox has new mail */
@@ -49,6 +50,11 @@ WHERE BUFFY *Incoming INITVAL (0);
 WHERE short BuffyTimeout INITVAL (3);
 WHERE short BuffyCheckStatsInterval INITVAL (60);
 
+#ifdef USE_NOTMUCH
+WHERE BUFFY *VirtIncoming INITVAL (0);
+void mutt_buffy_vfolder (char *s, size_t slen);
+#endif
+
 extern time_t BuffyDoneTime;	/* last time we knew for sure how much mail there was */
 
 BUFFY *mutt_find_mailbox (const char *path);
diff -r dd070f9b9ecd -r b19cab9fe4ad color.c
--- a/color.c	Sat Mar 31 14:15:41 2018 +0200
+++ b/color.c	Sat Mar 31 14:15:43 2018 +0200
@@ -40,6 +40,9 @@ COLOR_LINE *ColorIndexList = NULL;
 COLOR_LINE *ColorIndexAuthorList = NULL;
 COLOR_LINE *ColorIndexFlagsList = NULL;
 COLOR_LINE *ColorIndexSubjectList = NULL;
+#ifdef USE_NOTMUCH
+COLOR_LINE *ColorIndexTagList = NULL;
+#endif
 
 /* local to this file */
 static int ColorQuoteSize;
@@ -106,6 +109,10 @@ static const struct mapping_t Fields[] =
   { "index_number",	MT_COLOR_INDEX_NUMBER },
   { "index_size",	MT_COLOR_INDEX_SIZE },
   { "index_subject",	MT_COLOR_INDEX_SUBJECT },
+#ifdef USE_NOTMUCH
+  { "index_tag",	MT_COLOR_INDEX_TAG },
+  { "index_tags",	MT_COLOR_INDEX_TAGS },
+#endif
   { "progress",		MT_COLOR_PROGRESS },
   { "prompt",		MT_COLOR_PROMPT },
 #ifdef USE_SIDEBAR
@@ -531,6 +538,10 @@ static int _mutt_parse_uncolor (BUFFER *
     mutt_do_uncolor (buf, s, &ColorIndexFlagsList, &do_cache, parse_uncolor);
   else if (object == MT_COLOR_INDEX_SUBJECT)
     mutt_do_uncolor (buf, s, &ColorIndexSubjectList, &do_cache, parse_uncolor);
+#ifdef USE_NOTMUCH
+  else if (object == MT_COLOR_INDEX_TAG)
+    mutt_do_uncolor(buf, s, &ColorIndexTagList, &do_cache, parse_uncolor);
+#endif
 
   if (do_cache && !option (OPTNOCURSES))
   {
@@ -790,8 +801,10 @@ static int
       (object == MT_COLOR_INDEX) ||
       (object == MT_COLOR_INDEX_AUTHOR) ||
       (object == MT_COLOR_INDEX_FLAGS) ||
-      (object == MT_COLOR_INDEX_SUBJECT))
-  {
+#ifdef USE_NOTMUCH
+      (object == MT_COLOR_INDEX_TAG) ||
+#endif
+      (object == MT_COLOR_INDEX_SUBJECT)) {
     if (!MoreArgs (s))
     {
       strfcpy (err->data, _("too few arguments"), err->dsize);
@@ -870,6 +883,14 @@ static int
 			fg, bg, attr, err, 1, match);
     mutt_set_menu_redraw_full (MENU_MAIN);
   }
+#ifdef USE_NOTMUCH
+  else if (object == MT_COLOR_INDEX_TAG)
+  {
+    r = add_pattern (&ColorIndexTagList, buf->data, 1,
+		    fg, bg, attr, err, 1, match);
+    mutt_set_menu_redraw_full (MENU_MAIN);
+  }
+#endif
   else if (object == MT_COLOR_QUOTED)
   {
     if (q_level >= ColorQuoteSize)
diff -r dd070f9b9ecd -r b19cab9fe4ad commands.c
--- a/commands.c	Sat Mar 31 14:15:41 2018 +0200
+++ b/commands.c	Sat Mar 31 14:15:43 2018 +0200
@@ -40,6 +40,10 @@
 #include "imap.h"
 #endif
 
+#ifdef USE_NOTMUCH
+#include "mutt_notmuch.h"
+#endif
+
 #include "buffy.h"
 
 #include <errno.h>
@@ -61,6 +65,7 @@ int mutt_display_message (HEADER *cur)
   char tempfile[_POSIX_PATH_MAX], buf[LONG_STRING];
   int rc = 0, builtin = 0;
   int cmflags = MUTT_CM_DECODE | MUTT_CM_DISPLAY | MUTT_CM_CHARCONV;
+  int chflags;
   FILE *fpout = NULL;
   FILE *fpfilterout = NULL;
   pid_t filterpid = -1;
@@ -145,8 +150,14 @@ int mutt_display_message (HEADER *cur)
     fputs ("\n\n", fpout);
   }
 
-  res = mutt_copy_message (fpout, Context, cur, cmflags,
-       	(option (OPTWEED) ? (CH_WEED | CH_REORDER) : 0) | CH_DECODE | CH_FROM | CH_DISPLAY);
+  chflags = (option (OPTWEED) ? (CH_WEED | CH_REORDER) : 0)
+           | CH_DECODE | CH_FROM | CH_DISPLAY;
+#ifdef USE_NOTMUCH
+  if (Context->magic == MUTT_NOTMUCH)
+    chflags |= CH_VIRTUAL;
+#endif
+  res = mutt_copy_message (fpout, Context, cur, cmflags, chflags);
+
   if ((safe_fclose (&fpout) != 0 && errno != EPIPE) || res < 0)
   {
     mutt_error (_("Could not copy message"));
@@ -843,6 +854,10 @@ int mutt_save_message (HEADER *h, int de
     }
     else
     {
+#ifdef USE_NOTMUCH
+      if (Context->magic == MUTT_NOTMUCH)
+        nm_longrun_init(Context, TRUE);
+#endif
       for (i = 0; i < Context->vcount; i++)
       {
 	if (Context->hdrs[Context->v2r[i]]->tagged)
@@ -856,6 +871,10 @@ int mutt_save_message (HEADER *h, int de
           }
 	}
       }
+#ifdef USE_NOTMUCH
+      if (Context->magic == MUTT_NOTMUCH)
+        nm_longrun_done(Context);
+#endif
     }
 
     need_buffy_cleanup = (ctx.magic == MUTT_MBOX || ctx.magic == MUTT_MMDF);
diff -r dd070f9b9ecd -r b19cab9fe4ad compose.c
--- a/compose.c	Sat Mar 31 14:15:41 2018 +0200
+++ b/compose.c	Sat Mar 31 14:15:43 2018 +0200
@@ -1032,7 +1032,7 @@ int mutt_compose_menu (HEADER *msg,   /*
 	  numfiles = 0;
 	  files = NULL;
 
-	  if (_mutt_enter_fname (prompt, fname, sizeof (fname), 0, 1, &files, &numfiles) == -1 ||
+	  if (_mutt_enter_fname (prompt, fname, sizeof (fname), 0, 1, &files, &numfiles, 0) == -1 ||
 	      *fname == '\0')
 	    break;
 
@@ -1595,7 +1595,7 @@ int mutt_compose_menu (HEADER *msg,   /*
          if (msg->content->next)
            msg->content = mutt_make_multipart (msg->content);
 
-         if (mutt_write_fcc (fname, msg, NULL, 0, NULL) < 0)
+         if (mutt_write_fcc (fname, msg, NULL, 0, NULL, NULL) < 0)
            msg->content = mutt_remove_multipart (msg->content);
          else
            mutt_message _("Message written.");
diff -r dd070f9b9ecd -r b19cab9fe4ad configure.ac
--- a/configure.ac	Sat Mar 31 14:15:41 2018 +0200
+++ b/configure.ac	Sat Mar 31 14:15:43 2018 +0200
@@ -192,6 +192,30 @@ AS_IF([test x$enable_compressed = "xyes"
 ])
 AM_CONDITIONAL(BUILD_COMPRESS, test x$enable_compressed = xyes)
 
+AC_ARG_ENABLE(notmuch, AC_HELP_STRING([--enable-notmuch], [Enable NOTMUCH support]), enable_notmuch=$enableval, enable_notmuch=no)
+AS_IF([test x$enable_notmuch = "xyes"], [
+		AC_CHECK_LIB(notmuch, notmuch_database_open,,
+			AC_MSG_ERROR([Unable to find Notmuch library]))
+		AC_DEFINE(USE_NOTMUCH,1,[ Define if you want support for the notmuch. ])
+		NOTMUCH_LIBS="-lnotmuch"
+		OPS="$OPS \$(srcdir)/OPS.NOTMUCH"
+		need_notmuch="yes"
+
+		AC_MSG_CHECKING([for notmuch api version 3])
+		AC_COMPILE_IFELSE( [AC_LANG_PROGRAM(
+					[[#include <notmuch.h>]],
+					[[notmuch_database_open("/path", NOTMUCH_DATABASE_MODE_READ_ONLY, (notmuch_database_t**)NULL);]]
+					)],
+		[notmuch_api_3=yes
+			AC_DEFINE([NOTMUCH_API_3], 1, [Define to 1 if you have the notmuch api version 3.])
+			],
+		[notmuch_api_3=no]
+		)
+		AC_MSG_RESULT([$notmuch_api_3])
+])
+AM_CONDITIONAL(BUILD_NOTMUCH, test x$need_notmuch = xyes)
+
+
 AC_ARG_WITH(mixmaster, AS_HELP_STRING([--with-mixmaster@<:@=PATH@:>@],[Include Mixmaster support]),
   [if test "$withval" != no
    then
@@ -1184,6 +1208,7 @@ AC_SUBST(MUTTLIBS)
 AC_SUBST(MUTT_LIB_OBJECTS)
 AC_SUBST(LIBIMAP)
 AC_SUBST(LIBIMAPDEPS)
+AC_SUBST(NOTMUCH_LIBS)
 
 dnl -- iconv/gettext --
 
diff -r dd070f9b9ecd -r b19cab9fe4ad copy.c
--- a/copy.c	Sat Mar 31 14:15:41 2018 +0200
+++ b/copy.c	Sat Mar 31 14:15:43 2018 +0200
@@ -30,6 +30,10 @@
 #include "mutt_idna.h"
 #include "mutt_curses.h"
 
+#ifdef USE_NOTMUCH
+#include "mutt_notmuch.h"
+#endif
+
 #include <string.h>
 #include <stdlib.h>
 #include <ctype.h>
@@ -339,6 +343,7 @@ mutt_copy_hdr (FILE *in, FILE *out, LOFF
 	CH_NOQFROM      ignore ">From " line
 	CH_UPDATE_IRT	update the In-Reply-To: header
 	CH_UPDATE_REFS	update the References: header
+	CH_VIRTUAL      write virtual header lines too
 
    prefix
    	string to use if CH_PREFIX is set
@@ -352,7 +357,7 @@ mutt_copy_header (FILE *in, HEADER *h, F
   if (h->env)
     flags |= (h->env->irt_changed ? CH_UPDATE_IRT : 0)
       | (h->env->refs_changed ? CH_UPDATE_REFS : 0);
-  
+
   if (mutt_copy_hdr (in, out, h->offset, h->content->offset, flags, prefix) == -1)
     return -1;
 
@@ -418,6 +423,31 @@ mutt_copy_header (FILE *in, HEADER *h, F
       fprintf (out, "Lines: %d\n", h->lines);
   }
 
+#ifdef USE_NOTMUCH
+  if (flags & CH_VIRTUAL)
+  {
+    /* Add some fake headers based on notmuch data */
+    char *folder = nm_header_get_folder(h);
+    if (folder)
+    {
+      char buffer[LONG_STRING];
+      strfcpy (buffer, folder, sizeof (buffer));
+      mutt_pretty_mailbox (buffer, sizeof (buffer));
+
+      fputs ("Folder: ", out);
+      fputs (buffer, out);
+      fputc ('\n', out);
+    }
+    char *tags = nm_header_get_tags(h);
+    if (tags)
+    {
+      fputs ("Tags: ", out);
+      fputs (tags, out);
+      fputc ('\n', out);
+    }
+  }
+#endif
+
   if (flags & CH_UPDATE_LABEL)
   {
     h->xlabel_changed = 0;
@@ -699,7 +729,7 @@ mutt_copy_message (FILE *fpout, CONTEXT 
 {
   MESSAGE *msg;
   int r;
-  
+
   if ((msg = mx_open_message (src, hdr->msgno)) == NULL)
     return -1;
   if ((r = _mutt_copy_message (fpout, msg->fp, hdr, hdr->content, flags, chflags)) == 0 
@@ -734,7 +764,7 @@ int
   fseeko (fpin, hdr->offset, 0);
   if (fgets (buf, sizeof (buf), fpin) == NULL)
     return -1;
-  
+
   if ((msg = mx_open_new_message (dest, hdr, is_from (buf, NULL, 0, NULL) ? 0 : MUTT_ADD_FROM)) == NULL)
     return -1;
   if (dest->magic == MUTT_MBOX || dest->magic == MUTT_MMDF)
@@ -744,6 +774,11 @@ int
   if (mx_commit_message (msg, dest) != 0)
     r = -1;
 
+#ifdef USE_NOTMUCH
+  if (hdr && msg->commited_path && dest->magic == MUTT_MAILDIR && src->magic == MUTT_NOTMUCH)
+	  nm_update_filename(src, NULL, msg->commited_path, hdr);
+#endif
+
   mx_close_message (dest, &msg);
   return r;
 }
diff -r dd070f9b9ecd -r b19cab9fe4ad copy.h
--- a/copy.h	Sat Mar 31 14:15:41 2018 +0200
+++ b/copy.h	Sat Mar 31 14:15:43 2018 +0200
@@ -54,6 +54,7 @@
 #define CH_UPDATE_REFS    (1<<17) /* update References: */
 #define CH_DISPLAY        (1<<18) /* display result to user */
 #define CH_UPDATE_LABEL   (1<<19) /* update X-Label: from hdr->env->x_label? */
+#define CH_VIRTUAL	  (1<<20) /* write virtual header lines too */
 
 
 int mutt_copy_hdr (FILE *, FILE *, LOFF_T, LOFF_T, int, const char *);
diff -r dd070f9b9ecd -r b19cab9fe4ad curs_lib.c
--- a/curs_lib.c	Sat Mar 31 14:15:41 2018 +0200
+++ b/curs_lib.c	Sat Mar 31 14:15:43 2018 +0200
@@ -44,6 +44,10 @@
 #include <langinfo.h>
 #endif
 
+#ifdef USE_NOTMUCH
+#include "mutt_notmuch.h"
+#endif
+
 /* not possible to unget more than one char under some curses libs, and it
  * is impossible to unget function keys in SLang, so roll our own input
  * buffering routines.
@@ -876,7 +880,7 @@ int mutt_do_pager (const char *banner,
   return rc;
 }
 
-int _mutt_enter_fname (const char *prompt, char *buf, size_t blen, int buffy, int multiple, char ***files, int *numfiles)
+int _mutt_enter_fname (const char *prompt, char *buf, size_t blen, int buffy, int multiple, char ***files, int *numfiles, int flags)
 {
   event_t ch;
 
@@ -899,7 +903,9 @@ int _mutt_enter_fname (const char *promp
   {
     mutt_refresh ();
     buf[0] = 0;
-    _mutt_select_file (buf, blen, MUTT_SEL_FOLDER | (multiple ? MUTT_SEL_MULTI : 0), 
+    if (!flags)
+      flags = MUTT_SEL_FOLDER | (multiple ? MUTT_SEL_MULTI : 0);
+    _mutt_select_file (buf, blen, flags, 
 		       files, numfiles);
   }
   else
@@ -912,6 +918,10 @@ int _mutt_enter_fname (const char *promp
 	!= 0)
       buf[0] = 0;
     FREE (&pc);
+#ifdef USE_NOTMUCH
+    if ((flags & MUTT_SEL_VFOLDER) && buf[0] && strncmp(buf, "notmuch://", 10) != 0)
+      nm_description_to_path(buf, buf, blen);
+#endif
   }
 
   return 0;
diff -r dd070f9b9ecd -r b19cab9fe4ad curs_main.c
--- a/curs_main.c	Sat Mar 31 14:15:41 2018 +0200
+++ b/curs_main.c	Sat Mar 31 14:15:43 2018 +0200
@@ -42,6 +42,10 @@
 #include "imap_private.h"
 #endif
 
+#ifdef USE_NOTMUCH
+#include "mutt_notmuch.h"
+#endif
+
 #include "mutt_crypt.h"
 
 #ifdef USE_NNTP
@@ -608,6 +612,94 @@ dsl_finish:
 	FREE(&syntax);
 }
 
+#ifdef USE_NOTMUCH
+static int main_change_folder(MUTTMENU *menu, int op, char *buf, size_t bufsz,
+			  int *oldcount, int *index_hint, int flags)
+{
+#ifdef USE_NNTP
+  if (option (OPTNEWS))
+  {
+    unset_option (OPTNEWS);
+    nntp_expand_path (buf, bufsz, &CurrentNewsSrv->conn->account);
+  }
+  else
+#endif
+  mutt_expand_path (buf, bufsz);
+  if (mx_get_magic (buf) <= 0)
+  {
+    mutt_error (_("%s is not a mailbox."), buf);
+    return -1;
+  }
+  mutt_str_replace (&CurrentFolder, buf);
+
+  /* keepalive failure in mutt_enter_fname may kill connection. #3028 */
+  if (Context && !Context->path)
+    FREE (&Context);
+
+  if (Context)
+  {
+    int check;
+    char *new_last_folder;
+
+#ifdef USE_COMPRESSED
+	  if (Context->compress_info && Context->realpath)
+	    new_last_folder = safe_strdup (Context->realpath);
+	  else
+#endif
+	new_last_folder = safe_strdup (Context->path);
+	*oldcount = Context ? Context->msgcount : 0;
+
+    if ((check = mx_close_mailbox (Context, index_hint)) != 0)
+    {
+      if (check == MUTT_NEW_MAIL || check == MUTT_REOPENED)
+	    update_index (menu, Context, check, *oldcount, *index_hint);
+
+      FREE (&new_last_folder);
+      set_option (OPTSEARCHINVALID);
+      menu->redraw = REDRAW_INDEX | REDRAW_STATUS;
+      return 0;
+    }
+    FREE (&Context);
+    FREE (&LastFolder);
+    LastFolder = new_last_folder;
+  }
+  mutt_str_replace (&CurrentFolder, buf);
+
+  mutt_sleep (0);
+
+  /* Note that menu->menu may be MENU_PAGER if the change folder
+   * operation originated from the pager.
+   *
+   * However, exec commands currently use CurrentMenu to determine what
+   * functions are available, which is automatically set by the
+   * mutt_push/pop_current_menu() functions.  If that changes, the menu
+   * would need to be reset here, and the pager cleanup code after the
+   * switch statement would need to be run. */
+  mutt_folder_hook (buf);
+
+  if ((Context = mx_open_mailbox (buf,
+		(option (OPTREADONLY) || op == OP_MAIN_CHANGE_FOLDER_READONLY) ?
+		MUTT_READONLY : 0, NULL)) != NULL)
+  {
+    menu->current = ci_first_message ();
+  }
+  else
+    menu->current = 0;
+
+#ifdef USE_SIDEBAR
+        mutt_sb_set_open_buffy ();
+#endif
+
+  mutt_clear_error ();
+  mutt_buffy_check(1); /* force the buffy check after we have changed
+				the folder */
+  menu->redraw = REDRAW_FULL;
+  set_option (OPTSEARCHINVALID);
+
+  return 0;
+}
+#endif
+
 static const struct mapping_t IndexHelp[] = {
   { N_("Quit"),  OP_QUIT },
   { N_("Del"),   OP_DELETE },
@@ -1513,6 +1605,132 @@ int mutt_index_menu (void)
 	}
 	break;
 
+#ifdef USE_NOTMUCH
+      case OP_MAIN_ENTIRE_THREAD:
+      {
+	int oldcount  = Context->msgcount;
+	if (Context->magic != MUTT_NOTMUCH) {
+	  mutt_message _("No virtual folder, aborting.");
+	  break;
+	}
+	CHECK_MSGCOUNT;
+        CHECK_VISIBLE;
+	if (nm_read_entire_thread(Context, CURHDR) < 0) {
+	   mutt_message _("Failed to read thread, aborting.");
+	   break;
+	}
+	if (oldcount < Context->msgcount) {
+		HEADER *oldcur = CURHDR;
+
+		if ((Sort & SORT_MASK) == SORT_THREADS)
+			mutt_sort_headers (Context, 0);
+		menu->current = oldcur->virtual;
+		menu->redraw = REDRAW_STATUS | REDRAW_INDEX;
+
+		if (oldcur->collapsed || Context->collapsed) {
+			menu->current = mutt_uncollapse_thread(Context, CURHDR);
+			mutt_set_virtual(Context);
+		}
+	}
+	if (menu->menu == MENU_PAGER)
+	{
+	  op = OP_DISPLAY_MESSAGE;
+	  continue;
+	}
+	break;
+      }
+
+      case OP_MAIN_MODIFY_LABELS:
+      case OP_MAIN_MODIFY_LABELS_THEN_HIDE:
+      {
+	if (Context->magic != MUTT_NOTMUCH) {
+	  mutt_message _("No virtual folder, aborting.");
+	  break;
+	}
+	CHECK_MSGCOUNT;
+        CHECK_VISIBLE;
+	*buf = '\0';
+	if (mutt_get_field ("Add/remove labels: ", buf, sizeof (buf), MUTT_NM_TAG) || !*buf)
+	{
+          mutt_message _("No label specified, aborting.");
+          break;
+        }
+	if (tag)
+	{
+	  char msgbuf[STRING];
+	  progress_t progress;
+	  int px;
+
+	  if (!Context->quiet) {
+	    snprintf(msgbuf, sizeof (msgbuf), _("Update labels..."));
+	    mutt_progress_init(&progress, msgbuf, MUTT_PROGRESS_MSG,
+				   1, Context->tagged);
+	  }
+	  nm_longrun_init(Context, TRUE);
+	  for (px = 0, j = 0; j < Context->vcount; j++) {
+	    if (Context->hdrs[Context->v2r[j]]->tagged) {
+	      if (!Context->quiet)
+		mutt_progress_update(&progress, ++px, -1);
+	      nm_modify_message_tags(Context, Context->hdrs[Context->v2r[j]], buf);
+	      if (op == OP_MAIN_MODIFY_LABELS_THEN_HIDE)
+	      {
+		Context->hdrs[Context->v2r[j]]->quasi_deleted = TRUE;
+	        Context->changed = TRUE;
+	      }
+	    }
+	  }
+	  nm_longrun_done(Context);
+	  menu->redraw = REDRAW_STATUS | REDRAW_INDEX;
+	}
+	else
+	{
+	  if (nm_modify_message_tags(Context, CURHDR, buf)) {
+	    mutt_message _("Failed to modify labels, aborting.");
+	    break;
+	  }
+	  if (op == OP_MAIN_MODIFY_LABELS_THEN_HIDE)
+	  {
+	    CURHDR->quasi_deleted = TRUE;
+	    Context->changed = TRUE;
+	  }
+	  if (menu->menu == MENU_PAGER)
+	  {
+	    op = OP_DISPLAY_MESSAGE;
+	    continue;
+	  }
+	  if (option (OPTRESOLVE))
+	  {
+	    if ((menu->current = ci_next_undeleted (menu->current)) == -1)
+	    {
+	      menu->current = menu->oldcurrent;
+	      menu->redraw = REDRAW_CURRENT;
+	    }
+	    else
+	      menu->redraw = REDRAW_MOTION_RESYNCH;
+	  }
+	  else
+	    menu->redraw = REDRAW_CURRENT;
+	}
+	menu->redraw |= REDRAW_STATUS;
+	break;
+      }
+
+      case OP_MAIN_VFOLDER_FROM_QUERY:
+	buf[0] = '\0';
+        if (mutt_get_field ("Query: ", buf, sizeof (buf), MUTT_NM_QUERY) != 0 || !buf[0])
+        {
+          mutt_message _("No query, aborting.");
+          break;
+        }
+	if (!nm_uri_from_query(Context, buf, sizeof (buf)))
+	  mutt_message _("Failed to create query, aborting.");
+	else
+	  main_change_folder(menu, op, buf, sizeof (buf), &oldcount, &index_hint, 0);
+	break;
+
+      case OP_MAIN_CHANGE_VFOLDER:
+#endif
+
 #ifdef USE_SIDEBAR
       case OP_SIDEBAR_OPEN:
 #endif
@@ -1535,7 +1753,11 @@ int mutt_index_menu (void)
 
 	if (flags)
           cp = _("Open mailbox in read-only mode");
-        else
+#ifdef USE_NOTMUCH
+        else if (op == OP_MAIN_CHANGE_VFOLDER)
+	  cp = _("Open virtual folder");
+#endif
+	else
           cp = _("Open mailbox");
 
 	buf[0] = '\0';
@@ -1559,6 +1781,20 @@ int mutt_index_menu (void)
           strncpy (buf, path, sizeof (buf));
         }
 #endif
+#ifdef USE_NOTMUCH
+	else if (op == OP_MAIN_CHANGE_VFOLDER) {
+	  if (Context->magic == MUTT_NOTMUCH) {
+		  strfcpy(buf, Context->path, sizeof (buf));
+		  mutt_buffy_vfolder (buf, sizeof (buf));
+	  }
+	  mutt_enter_vfolder (cp, buf, sizeof (buf), 1);
+	  if (!buf[0])
+	  {
+            mutt_window_clearline (MuttMessageWindow, 0);
+	    break;
+	  }
+	}
+#endif
 	else
 	{
 #ifdef USE_NNTP
@@ -2864,12 +3100,21 @@ int mutt_index_menu (void)
 	toggle_option (OPTSIDEBAR);
         mutt_reflow_windows();
 	break;
+
+      case OP_SIDEBAR_TOGGLE_VIRTUAL:
+	mutt_sb_toggle_virtual();
+	break;
 #endif
       default:
 	if (menu->menu == MENU_MAIN)
 	  km_error_key (MENU_MAIN);
     }
 
+#ifdef USE_NOTMUCH
+    if (Context)
+      nm_debug_check(Context);
+#endif
+
     if (menu->menu == MENU_PAGER)
     {
       mutt_clear_pager_position ();
diff -r dd070f9b9ecd -r b19cab9fe4ad enter.c
--- a/enter.c	Sat Mar 31 14:15:41 2018 +0200
+++ b/enter.c	Sat Mar 31 14:15:43 2018 +0200
@@ -686,6 +686,27 @@ int _mutt_enter_string (char *buf, size_
 	      BEEP (); /* let the user know that nothing matched */
 	    replace_part (state, 0, buf);
 	  }
+#if USE_NOTMUCH
+	  else if (flags & MUTT_NM_QUERY)
+	  {
+	    my_wcstombs (buf, buflen, state->wbuf, state->curpos);
+	    i = strlen (buf);
+	    if (!mutt_nm_query_complete(buf, buflen, i, state->tabs))
+	      BEEP ();
+
+	    replace_part (state, 0, buf);
+	  }
+	  else if (flags & MUTT_NM_TAG)
+	  {
+	    my_wcstombs (buf, buflen, state->wbuf, state->curpos);
+	    i = strlen (buf);
+	    if (!mutt_nm_tag_complete(buf, buflen, i, state->tabs))
+	      BEEP ();
+
+	    replace_part (state, 0, buf);
+	  }
+
+#endif
 	  else
 	    goto self_insert;
 	  break;
diff -r dd070f9b9ecd -r b19cab9fe4ad functions.h
--- a/functions.h	Sat Mar 31 14:15:41 2018 +0200
+++ b/functions.h	Sat Mar 31 14:15:43 2018 +0200
@@ -200,9 +200,17 @@ const struct binding_t OpMain[] = { /* m
   { "sidebar-page-up",		OP_SIDEBAR_PAGE_UP,		NULL },
   { "sidebar-prev",		OP_SIDEBAR_PREV,		NULL },
   { "sidebar-prev-new",		OP_SIDEBAR_PREV_NEW,		NULL },
+  { "sidebar-toggle-virtual",	OP_SIDEBAR_TOGGLE_VIRTUAL,	NULL },
   { "sidebar-toggle-visible",	OP_SIDEBAR_TOGGLE_VISIBLE,	NULL },
 #endif
 
+#ifdef USE_NOTMUCH
+  { "change-vfolder",		OP_MAIN_CHANGE_VFOLDER,         NULL },
+  { "vfolder-from-query",	OP_MAIN_VFOLDER_FROM_QUERY,     NULL },
+  { "modify-labels",		OP_MAIN_MODIFY_LABELS,		NULL },
+  { "modify-labels-then-hide",	OP_MAIN_MODIFY_LABELS_THEN_HIDE, NULL },
+  { "entire-thread",		OP_MAIN_ENTIRE_THREAD,          NULL },
+#endif
   { NULL,			0,				NULL }
 };
 
@@ -330,9 +338,18 @@ const struct binding_t OpPager[] = { /* 
   { "sidebar-page-up",		OP_SIDEBAR_PAGE_UP,		NULL },
   { "sidebar-prev",		OP_SIDEBAR_PREV,		NULL },
   { "sidebar-prev-new",		OP_SIDEBAR_PREV_NEW,		NULL },
+  { "sidebar-toggle-virtual",	OP_SIDEBAR_TOGGLE_VIRTUAL,	NULL },
   { "sidebar-toggle-visible",	OP_SIDEBAR_TOGGLE_VISIBLE,	NULL },
 #endif
 
+#ifdef USE_NOTMUCH
+  { "change-vfolder",		OP_MAIN_CHANGE_VFOLDER,		NULL },
+  { "vfolder-from-query",	OP_MAIN_VFOLDER_FROM_QUERY,	NULL },
+  { "modify-labels",		OP_MAIN_MODIFY_LABELS,		NULL },
+  { "modify-labels-then-hide",	OP_MAIN_MODIFY_LABELS_THEN_HIDE, NULL },
+  { "entire-thread",		OP_MAIN_ENTIRE_THREAD,          NULL },
+#endif
+
   { NULL,		0,				NULL }
 };
 
diff -r dd070f9b9ecd -r b19cab9fe4ad globals.h
--- a/globals.h	Sat Mar 31 14:15:41 2018 +0200
+++ b/globals.h	Sat Mar 31 14:15:43 2018 +0200
@@ -177,6 +177,10 @@ WHERE const char *ReleaseDate;
 
 WHERE HASH *Groups;
 WHERE HASH *ReverseAlias;
+#ifdef USE_NOTMUCH
+WHERE HASH *TagTransforms;
+WHERE HASH *TagFormats;
+#endif
 
 WHERE LIST *AutoViewList INITVAL(0);
 WHERE LIST *AlternativeOrderList INITVAL(0);
@@ -306,6 +310,17 @@ WHERE char *SmimeImportCertCommand;
 WHERE char *SmimeGetCertEmailCommand;
 WHERE char *SmimeSelfEncryptAs;
 
+#ifdef USE_NOTMUCH
+WHERE int NotmuchOpenTimeout;
+WHERE char *NotmuchDefaultUri;
+WHERE char *NotmuchExcludeTags;
+WHERE char *NotmuchUnreadTag;
+WHERE char *NotmuchHiddenTags;
+WHERE char *VirtFolderFormat;
+WHERE int NotmuchDBLimit;
+WHERE char *NotmuchQueryType;
+WHERE char *NotmuchRecordTags;
+#endif
 
 
 
diff -r dd070f9b9ecd -r b19cab9fe4ad hdrline.c
--- a/hdrline.c	Sat Mar 31 14:15:41 2018 +0200
+++ b/hdrline.c	Sat Mar 31 14:15:43 2018 +0200
@@ -36,6 +36,14 @@
 #include <alloca.h>
 #endif
 
+#ifdef USE_NNTP
+#include "mx.h"
+#endif
+
+#ifdef USE_NOTMUCH
+#include "mutt_notmuch.h"
+#endif
+
 int mutt_is_mail_list (ADDRESS *addr)
 {
   if (!mutt_match_rx_list (addr->mailbox, UnMailLists))
@@ -260,6 +268,7 @@ static char *apply_subject_mods (ENVELOP
  * %f = entire from line
  * %F = like %n, unless from self
  * %g = newsgroup name (if compiled with NNTP support)
+ * %g = message labels (e.g. notmuch tags)
  * %i = message-id
  * %I = initials of author
  * %l = number of lines in the message
@@ -604,12 +613,32 @@ hdr_format_str (char *dest,
         optional = 0;
       break;
 
-#ifdef USE_NNTP
+#if defined USE_NNTP || defined USE_NOTMUCH
     case 'g':
+#endif
+#if defined USE_NNTP
+	  if (ctx->magic == MUTT_NNTP) {
       mutt_format_s (dest, destlen, prefix, hdr->env->newsgroups ? hdr->env->newsgroups : "");
+	  }
+#endif
+#if defined USE_NNTP && defined USE_NOTMUCH
+	  else
+#endif
+#if defined USE_NOTMUCH
+      if (!optional)
+      {
+        colorlen = add_index_color(dest, destlen, flags, MT_COLOR_INDEX_TAGS);
+        mutt_format_s (dest+colorlen, destlen-colorlen, prefix, nm_header_get_tags_transformed(hdr));
+        add_index_color(dest+colorlen, destlen-colorlen, flags, MT_COLOR_INDEX);
+      }
+      else if (!nm_header_get_tags_transformed(hdr))
+        optional = 0;
+#endif
+#if defined USE_NNTP || defined USE_NOTMUCH
       break;
 #endif
 
+
     case 'H':
       /* (Hormel) spam score */
       if (optional)
@@ -966,6 +995,48 @@ hdr_format_str (char *dest,
 
       break;
 
+#ifdef USE_NOTMUCH
+    case 'G':
+    {
+      char *tag_transformed;
+      char format[3];
+      char *tag;
+
+      if (!optional)
+      {
+        format[0] = op;
+        format[1] = *src;
+        format[2] = 0;
+
+        tag = hash_find(TagFormats, format);
+        if (tag != NULL)
+        {
+            tag_transformed = nm_header_get_tag_transformed(tag, hdr);
+
+            colorlen = add_index_color(dest, destlen, flags, MT_COLOR_INDEX_TAG);
+            mutt_format_s (dest+colorlen, destlen-colorlen, prefix,
+                           (tag_transformed) ? tag_transformed : "");
+            add_index_color(dest+colorlen, destlen-colorlen, flags, MT_COLOR_INDEX);
+        }
+
+        src++;
+      }
+      else
+      {
+        format[0] = op;
+        format[1] = *prefix;
+        format[2] = 0;
+
+        tag = hash_find(TagFormats, format);
+        if (tag != NULL)
+          if (nm_header_get_tag_transformed(tag, hdr) == NULL)
+            optional = 0;
+      }
+
+      break;
+    }
+#endif
+
     default:
       snprintf (dest, destlen, "%%%s%c", prefix, op);
       break;
diff -r dd070f9b9ecd -r b19cab9fe4ad init.c
--- a/init.c	Sat Mar 31 14:15:41 2018 +0200
+++ b/init.c	Sat Mar 31 14:15:43 2018 +0200
@@ -38,7 +38,9 @@
 #include "mutt_ssl.h"
 #endif
 
-
+#if USE_NOTMUCH
+#include "mutt_notmuch.h"
+#endif
 
 #include "mx.h"
 #include "init.h"
@@ -79,6 +81,12 @@ static void myvar_del (const char* var);
 
 extern char **envlist;
 
+#if USE_NOTMUCH
+/* List of tags found in last call to mutt_nm_query_complete(). */
+static char **nm_tags;
+#endif
+
+
 static void toggle_quadoption (int opt)
 {
   int n = opt/4;
@@ -3123,6 +3131,182 @@ int mutt_var_value_complete (char *buffe
   return 0;
 }
 
+#if USE_NOTMUCH
+
+/* Fetch a list of all notmuch tags and insert them into the completion
+ * machinery.
+ */
+static int complete_all_nm_tags (const char *pt)
+{
+  int num;
+  int tag_count_1 = 0;
+  int tag_count_2 = 0;
+
+  Num_matched = 0;
+  strfcpy (User_typed, pt, sizeof (User_typed));
+  memset (Matches, 0, Matches_listsize);
+  memset (Completed, 0, sizeof (Completed));
+
+  nm_longrun_init(Context, FALSE);
+
+  /* Work out how many tags there are. */
+  if (nm_get_all_tags(Context, NULL, &tag_count_1) || tag_count_1 == 0)
+    goto done;
+
+  /* Free the old list, if any. */
+  if (nm_tags != NULL) {
+    int i;
+    for (i = 0; nm_tags[i] != NULL; i++)
+      FREE (&nm_tags[i]);
+    FREE (&nm_tags);
+  }
+  /* Allocate a new list, with sentinel. */
+  nm_tags = safe_malloc((tag_count_1 + 1) * sizeof (char *));
+  nm_tags[tag_count_1] = NULL;
+
+  /* Get all the tags. */
+  if (nm_get_all_tags(Context, nm_tags, &tag_count_2) ||
+      tag_count_1 != tag_count_2) {
+    FREE (&nm_tags);
+    nm_tags = NULL;
+    nm_longrun_done(Context);
+    return -1;
+  }
+
+  /* Put them into the completion machinery. */
+  for (num = 0; num < tag_count_1; num++) {
+    candidate (Completed, User_typed, nm_tags[num], sizeof (Completed));
+  }
+
+  matches_ensure_morespace (Num_matched);
+  Matches[Num_matched++] = User_typed;
+
+done:
+  nm_longrun_done(Context);
+  return 0;
+}
+
+/* Return the last instance of needle in the haystack, or NULL.
+ * Like strstr(), only backwards, and for a limited haystack length.
+ */
+static const char* rstrnstr(const char* haystack,
+                            size_t haystack_length,
+                            const char* needle)
+{
+  int needle_length = strlen(needle);
+  const char* haystack_end = haystack + haystack_length - needle_length;
+  const char* p;
+
+  for (p = haystack_end; p >= haystack; --p)
+  {
+    size_t i;
+    for (i = 0; i < needle_length; ++i) {
+      if (p[i] != needle[i])
+        goto next;
+    }
+    return p;
+
+    next:;
+  }
+  return NULL;
+}
+
+/* Complete the nearest "tag:"-prefixed string previous to pos. */
+int mutt_nm_query_complete (char *buffer, size_t len, int pos, int numtabs)
+{
+  char *pt = buffer;
+  int spaces;
+
+  SKIPWS (buffer);
+  spaces = buffer - pt;
+
+  pt = (char *)rstrnstr((char *)buffer, pos, "tag:");
+  if (pt != NULL) {
+    pt += 4;
+    if (numtabs == 1) {
+      /* First TAB. Collect all the matches */
+      complete_all_nm_tags(pt);
+
+      /* All matches are stored. Longest non-ambiguous string is ""
+       * i.e. don't change 'buffer'. Fake successful return this time.
+       */
+      if (User_typed[0] == 0)
+	return 1;
+    }
+
+    if (Completed[0] == 0 && User_typed[0])
+      return 0;
+
+    /* Num_matched will _always_ be atleast 1 since the initial
+     * user-typed string is always stored */
+    if (numtabs == 1 && Num_matched == 2)
+      snprintf(Completed, sizeof(Completed),"%s", Matches[0]);
+    else if (numtabs > 1 && Num_matched > 2)
+      /* cycle thru all the matches */
+      snprintf(Completed, sizeof(Completed), "%s",
+	       Matches[(numtabs - 2) % Num_matched]);
+
+    /* return the completed query */
+    strncpy (pt, Completed, buffer + len - pt - spaces);
+  }
+  else
+    return 0;
+
+  return 1;
+}
+
+/* Complete the nearest "+" or "-" -prefixed string previous to pos. */
+int mutt_nm_tag_complete (char *buffer, size_t len, int pos, int numtabs)
+{
+  char *pt = buffer;
+  int spaces;
+  const char *first_plus = NULL;
+  const char *first_minus = NULL;
+
+  SKIPWS (buffer);
+  spaces = buffer - pt;
+
+  first_plus = rstrnstr((char *)buffer, pos, "+");
+  first_minus = rstrnstr((char *)buffer, pos, "-");
+  pt = (char *)MAX(first_plus, first_minus);
+
+  if (pt != NULL) {
+    pt++;
+
+    if (numtabs == 1)
+    {
+      /* First TAB. Collect all the matches */
+      complete_all_nm_tags(pt);
+
+      /* All matches are stored. Longest non-ambiguous string is ""
+       * i.e. don't change 'buffer'. Fake successful return this time.
+       */
+      if (User_typed[0] == 0)
+	return 1;
+    }
+
+    if (Completed[0] == 0 && User_typed[0])
+      return 0;
+
+    /* Num_matched will _always_ be atleast 1 since the initial
+     * user-typed string is always stored */
+    if (numtabs == 1 && Num_matched == 2)
+      snprintf(Completed, sizeof(Completed),"%s", Matches[0]);
+    else if (numtabs > 1 && Num_matched > 2)
+      /* cycle thru all the matches */
+      snprintf(Completed, sizeof(Completed), "%s",
+	       Matches[(numtabs - 2) % Num_matched]);
+
+    /* return the completed query */
+    strncpy (pt, Completed, buffer + len - pt - spaces);
+  }
+  else
+    return 0;
+
+  return 1;
+}
+#endif
+
 static int var_to_string (int idx, char* val, size_t len)
 {
   char tmp[LONG_STRING];
@@ -3438,6 +3622,11 @@ void mutt_init (int skip_sys_rc, LIST *c
   ReverseAlias = hash_create (1031, MUTT_HASH_STRCASECMP | MUTT_HASH_STRDUP_KEYS |
                               MUTT_HASH_ALLOW_DUPS);
   
+#ifdef USE_NOTMUCH
+  TagTransforms = hash_create (64, MUTT_HASH_STRCASECMP);
+  TagFormats = hash_create (64, 0);
+#endif
+
   mutt_menu_init ();
   mutt_srandom ();
 
@@ -3732,6 +3921,11 @@ void mutt_init (int skip_sys_rc, LIST *c
 
   mutt_read_histfile ();
 
+#ifdef USE_NOTMUCH
+  if (option (OPTVIRTSPOOLFILE) && VirtIncoming)
+    mutt_str_replace(&Spoolfile, VirtIncoming->path);
+#endif
+
 #if 0
   set_option (OPTWEED); /* turn weeding on by default */
 #endif
@@ -3779,6 +3973,70 @@ static int parse_group_context (group_co
   return -1;
 }
 
+#ifdef USE_NOTMUCH
+int parse_tag_transforms (BUFFER *b, BUFFER *s, unsigned long data, BUFFER *err)
+{
+  char *tmp;
+
+  while (MoreArgs (s))
+  {
+    char *tag, *transform;
+
+    mutt_extract_token (b, s, 0);
+    if (b->data && *b->data)
+      tag = safe_strdup (b->data);
+    else
+      continue;
+
+    mutt_extract_token (b, s, 0);
+    transform = safe_strdup (b->data);
+
+    /* avoid duplicates */
+    tmp = hash_find(TagTransforms, tag);
+    if (tmp) {
+      dprint(3,(debugfile,"tag transform '%s' already registered as '%s'\n", tag, tmp));
+      FREE(&tag);
+      FREE(&transform);
+      continue;
+    }
+
+    hash_insert(TagTransforms, tag, transform);
+  }
+  return 0;
+}
+
+int parse_tag_formats (BUFFER *b, BUFFER *s, unsigned long data, BUFFER *err)
+{
+  char *tmp;
+
+  while (MoreArgs (s))
+  {
+    char *tag, *format;
+
+    mutt_extract_token (b, s, 0);
+    if (b->data && *b->data)
+      tag = safe_strdup (b->data);
+    else
+      continue;
+
+    mutt_extract_token (b, s, 0);
+    format = safe_strdup (b->data);
+
+    /* avoid duplicates */
+    tmp = hash_find(TagFormats, format);
+    if (tmp) {
+      dprint(3,(debugfile,"tag format '%s' already registered as '%s'\n", format, tmp));
+      FREE(&tag);
+      FREE(&format);
+      continue;
+    }
+
+    hash_insert(TagFormats, format, tag);
+  }
+  return 0;
+}
+#endif
+
 static void myvar_set (const char* var, const char* val)
 {
   myvar_t** cur;
diff -r dd070f9b9ecd -r b19cab9fe4ad init.h
--- a/init.h	Sat Mar 31 14:15:41 2018 +0200
+++ b/init.h	Sat Mar 31 14:15:43 2018 +0200
@@ -1451,6 +1451,7 @@ struct option_t MuttVars[] = {
   ** .dt %f .dd sender (address + real name), either From: or Return-Path:
   ** .dt %F .dd author name, or recipient name if the message is from you
   ** .dt %g .dd newsgroup name (if compiled with NNTP support)
+  ** .dt %g .dd message labels (e.g. notmuch tags)
   ** .dt %H .dd spam attribute(s) of this message
   ** .dt %i .dd message-id of the current message
   ** .dt %l .dd number of lines in the message (does not work with maildir,
@@ -1980,6 +1981,60 @@ struct option_t MuttVars[] = {
   ** etc.).
   */
 #endif
+#ifdef USE_NOTMUCH
+  { "nm_open_timeout", DT_NUM, R_NONE, UL &NotmuchOpenTimeout, 5 },
+  /*
+   ** .pp
+   ** This variable specifies the timeout for database open in seconds.
+   */
+
+  { "nm_default_uri", DT_STR, R_NONE, UL &NotmuchDefaultUri, 0 },
+  /*
+   ** .pp
+   ** This variable specifies the default Notmuch database in format
+   ** notmuch://<absolute path>.
+   */
+
+  { "nm_hidden_tags", DT_STR, R_NONE, UL &NotmuchHiddenTags, UL "unread,draft,flagged,passed,replied,attachment,signed,encrypted" },
+  /*
+   ** .pp
+   ** This variable specifies private notmuch tags which should not be printed
+   ** on screen.
+   */
+  { "nm_exclude_tags", DT_STR,  R_NONE, UL &NotmuchExcludeTags, 0 },
+  /*
+   ** .pp
+   ** The messages tagged with these tags are excluded and not loaded
+   ** from notmuch DB to mutt unless specified explicitly.
+   */
+  { "nm_unread_tag", DT_STR, R_NONE, UL &NotmuchUnreadTag, UL "unread" },
+  /*
+   ** .pp
+   ** This variable specifies notmuch tag which is used for unread messages. The
+   ** variable is used to count unread messages in DB only. All other mutt commands
+   ** use standard (e.g. maildir) flags.
+   */
+  { "nm_db_limit", DT_NUM, R_NONE, UL &NotmuchDBLimit, 0 },
+  /*
+   ** .pp
+   ** This variable specifies the default limit used in notmuch queries.
+   */
+  { "nm_query_type", DT_STR, R_NONE, UL &NotmuchQueryType, UL "messages" },
+  /*
+   ** .pp
+   ** This variable specifies the default query type (threads or messages) used in notmuch queries.
+   */
+  { "nm_record", DT_BOOL, R_NONE, OPTNOTMUCHRECORD, 0 },
+  /*
+   ** .pp
+   ** This variable specifies if the mutt record should indexed by notmuch.
+   */
+  { "nm_record_tags", DT_STR, R_NONE, UL &NotmuchRecordTags, 0 },
+  /*
+   ** .pp
+   ** This variable specifies the default tags applied to messages stored to the mutt record.
+   */
+#endif
   { "pager",		DT_PATH, R_NONE, UL &Pager, UL "builtin" },
   /*
   ** .pp
@@ -3594,14 +3649,15 @@ struct option_t MuttVars[] = {
   { "sort_re",		DT_BOOL, R_INDEX|R_RESORT|R_RESORT_INIT, OPTSORTRE, 1 },
   /*
   ** .pp
-  ** This variable is only useful when sorting by threads with
-  ** $$strict_threads \fIunset\fP.  In that case, it changes the heuristic
-  ** mutt uses to thread messages by subject.  With $$sort_re \fIset\fP, mutt will
-  ** only attach a message as the child of another message by subject if
-  ** the subject of the child message starts with a substring matching the
-  ** setting of $$reply_regexp.  With $$sort_re \fIunset\fP, mutt will attach
-  ** the message whether or not this is the case, as long as the
-  ** non-$$reply_regexp parts of both messages are identical.
+  ** This variable is only useful when sorting by mailboxes in sidebar. By default,
+  ** entries are unsorted.  Valid values:
+  ** .il
+  ** .dd count (all message count)
+  ** .dd desc  (virtual mailbox description)
+  ** .dd new (new message count)
+  ** .dd path
+  ** .dd unsorted
+  ** .ie
   */
   { "spam_separator",   DT_STR, R_NONE, UL &SpamSep, UL "," },
   /*
@@ -4080,6 +4136,21 @@ struct option_t MuttVars[] = {
   ** Specifies the visual editor to invoke when the ``\fC~v\fP'' command is
   ** given in the built-in editor.
   */
+#ifdef USE_NOTMUCH
+  { "vfolder_format",	DT_STR,	 R_INDEX, UL &VirtFolderFormat, UL "%2C %?n?%4n/&     ?%4m %f" },
+  /*
+  ** .pp
+  ** This variable allows you to customize the file browser display for virtual
+  ** folders to your personal taste.  This string uses many of the same
+  ** expandos as $$folder_format.
+  */
+  { "virtual_spoolfile", DT_BOOL, R_NONE, OPTVIRTSPOOLFILE, 0 },
+  /*
+  ** .pp
+  ** When \fset\fP, mutt will use the first defined virtual mailbox (see
+  ** virtual-mailboxes) as a spool file.
+  */
+#endif
   { "wait_key",		DT_BOOL, R_NONE, OPTWAITKEY, 1 },
   /*
   ** .pp
@@ -4241,6 +4312,7 @@ const struct mapping_t SortKeyMethods[] 
 const struct mapping_t SortSidebarMethods[] = {
   { "alpha",		SORT_PATH },
   { "count",		SORT_COUNT },
+  { "desc",		SORT_DESC },
   { "flagged",		SORT_FLAGGED },
   { "mailbox-order",	SORT_ORDER },
   { "name",		SORT_PATH },
@@ -4293,6 +4365,11 @@ static int parse_unalternates (BUFFER *,
 /* Parse -group arguments */
 static int parse_group_context (group_context_t **ctx, BUFFER *buf, BUFFER *s, unsigned long data, BUFFER *err);
 
+#ifdef USE_NOTMUCH
+static int parse_tag_transforms (BUFFER *, BUFFER *, unsigned long, BUFFER *);
+static int parse_tag_formats (BUFFER *, BUFFER *, unsigned long, BUFFER *);
+#endif
+
 
 struct command_t
 {
@@ -4341,6 +4418,11 @@ const struct command_t Commands[] = {
   { "macro",		mutt_parse_macro,	0 },
   { "mailboxes",	mutt_parse_mailboxes,	MUTT_MAILBOXES },
   { "unmailboxes",	mutt_parse_mailboxes,	MUTT_UNMAILBOXES },
+#ifdef USE_NOTMUCH
+  { "virtual-mailboxes",mutt_parse_virtual_mailboxes, 0 },
+  { "tag-transforms",	parse_tag_transforms,	0 },
+  { "tag-formats",	parse_tag_formats,	0 },
+#endif
   { "mailto_allow",	parse_list,		UL &MailtoAllow },
   { "unmailto_allow",	parse_unlist,		UL &MailtoAllow },
   { "message-hook",	mutt_parse_hook,	MUTT_MESSAGEHOOK },
diff -r dd070f9b9ecd -r b19cab9fe4ad mailbox.h
--- a/mailbox.h	Sat Mar 31 14:15:41 2018 +0200
+++ b/mailbox.h	Sat Mar 31 14:15:43 2018 +0200
@@ -48,6 +48,7 @@ typedef struct _message
 {
   FILE *fp;	/* pointer to the message data */
   char *path;	/* path to temp file */
+  char *commited_path; /* the final path generated by mx_commit_message() */
   short write;	/* nonzero if message is open for writing */
   struct {
     unsigned read : 1;
diff -r dd070f9b9ecd -r b19cab9fe4ad menu.c
--- a/menu.c	Sat Mar 31 14:15:41 2018 +0200
+++ b/menu.c	Sat Mar 31 14:15:43 2018 +0200
@@ -56,6 +56,17 @@ get_color (int index, unsigned char *s)
 		case MT_COLOR_INDEX_SUBJECT:
 			color = ColorIndexSubjectList;
 			break;
+#ifdef USE_NOTMUCH
+		case MT_COLOR_INDEX_TAG:
+			for (color = ColorIndexTagList; color; color = color->next)
+			{
+				const char * transform = hash_find(TagTransforms, color->pattern);
+				if (transform && (strncmp((const char *)(s+1),
+								transform, strlen(transform)) == 0))
+					return color->pair;
+			}
+			return 0;
+#endif
 		default:
 			return ColorDefs[type];
 	}
diff -r dd070f9b9ecd -r b19cab9fe4ad mh.c
--- a/mh.c	Sat Mar 31 14:15:41 2018 +0200
+++ b/mh.c	Sat Mar 31 14:15:43 2018 +0200
@@ -56,6 +56,14 @@
 #include <sys/time.h>
 #endif
 
+#ifdef USE_NOTMUCH
+#include "mutt_notmuch.h"
+#endif
+
+#ifdef USE_NOTMUCH
+#include "mutt_notmuch.h"
+#endif
+
 #define		INS_SORT_THRESHOLD		6
 
 static int maildir_check_mailbox (CONTEXT * ctx, int *index_hint);
@@ -661,7 +669,7 @@ static void maildir_free_maildir (struct
   }
 }
 
-static void maildir_parse_flags (HEADER * h, const char *path)
+void maildir_parse_flags (HEADER * h, const char *path)
 {
   char *p, *q = NULL;
 
@@ -747,40 +755,51 @@ static void maildir_update_mtime (CONTEX
  * Actually parse a maildir message.  This may also be used to fill
  * out a fake header structure generated by lazy maildir parsing.
  */
-static HEADER *maildir_parse_message (int magic, const char *fname,
+HEADER *maildir_parse_stream (int magic, FILE *f, const char *fname,
 				      int is_old, HEADER * _h)
 {
-  FILE *f;
   HEADER *h = _h;
   struct stat st;
 
-  if ((f = fopen (fname, "r")) != NULL)
+  if (!h)
+    h = mutt_new_header ();
+  h->env = mutt_read_rfc822_header (f, h, 0, 0);
+
+  fstat (fileno (f), &st);
+
+  if (!h->received)
+    h->received = h->date_sent;
+
+  /* always update the length since we have fresh information available. */
+  h->content->length = st.st_size - h->content->offset;
+
+  h->index = -1;
+
+  if (magic == MUTT_MAILDIR)
   {
-    if (!h)
-      h = mutt_new_header ();
-    h->env = mutt_read_rfc822_header (f, h, 0, 0);
-
-    fstat (fileno (f), &st);
+    /*
+     * maildir stores its flags in the filename, so ignore the
+     * flags in the header of the message
+     */
+
+    h->old = is_old;
+    maildir_parse_flags (h, fname);
+  }
+  return h;
+}
+
+/*
+ * Actually parse a maildir message.  This may also be used to fill
+ * out a fake header structure generated by lazy maildir parsing.
+ */
+HEADER *maildir_parse_message (int magic, const char *fname,
+				      int is_old, HEADER * h)
+{
+  FILE *f;
+
+  if ((f = fopen (fname, "r")) != NULL) {
+    h = maildir_parse_stream (magic, f, fname, is_old, h);
     safe_fclose (&f);
-
-    if (!h->received)
-      h->received = h->date_sent;
-
-    /* always update the length since we have fresh information available. */
-    h->content->length = st.st_size - h->content->offset;
-
-    h->index = -1;
-
-    if (magic == MUTT_MAILDIR)
-    {
-      /* 
-       * maildir stores its flags in the filename, so ignore the
-       * flags in the header of the message 
-       */
-
-      h->old = is_old;
-      maildir_parse_flags (h, fname);
-    }
     return h;
   }
   return NULL;
@@ -1388,7 +1407,7 @@ static int ch_compar (const void *a, con
   return (int)( *((const char *) a) - *((const char *) b));
 }
 
-static void maildir_flags (char *dest, size_t destlen, HEADER * hdr)
+void maildir_flags (char *dest, size_t destlen, HEADER * hdr)
 {
   *dest = '\0';
 
@@ -1425,7 +1444,7 @@ static int maildir_mh_open_message (CONT
 
   msg->fp = fopen (path, "r");
   if (msg->fp == NULL && errno == ENOENT && is_maildir)
-    msg->fp = maildir_open_find_message (ctx->path, cur->path);
+    msg->fp = maildir_open_find_message (ctx->path, cur->path, NULL);
 
   if (!msg->fp)
   {
@@ -1585,10 +1604,6 @@ static int _maildir_commit_message (CONT
 
     if (safe_rename (msg->path, full) == 0)
     {
-      if (hdr)
-	mutt_str_replace (&hdr->path, path);
-      FREE (&msg->path);
-
       /*
        * Adjust the mtime on the file to match the time at which this
        * message was received.  Currently this is only set when copying
@@ -1604,11 +1619,23 @@ static int _maildir_commit_message (CONT
 	if (utime (full, &ut))
 	{
 	  mutt_perror (_("_maildir_commit_message(): unable to set time on file"));
-	  return -1;
+	  goto post_rename_err;
 	}
       }
 
+#ifdef USE_NOTMUCH
+      if (ctx->magic == MUTT_NOTMUCH)
+	nm_update_filename(ctx, hdr->path, full, hdr);
+#endif
+      if (hdr)
+	mutt_str_replace (&hdr->path, path);
+      mutt_str_replace (&msg->commited_path, full);
+      FREE (&msg->path);
+
       return 0;
+
+post_rename_err:
+      return -1;
     }
     else if (errno != EEXIST)
     {
@@ -1689,6 +1716,7 @@ static int _mh_commit_message (CONTEXT *
     {
       if (hdr)
 	mutt_str_replace (&hdr->path, tmp);
+      mutt_str_replace (&msg->commited_path, path);
       FREE (&msg->path);
       break;
     }
@@ -1864,9 +1892,76 @@ static int maildir_sync_message (CONTEXT
   return (0);
 }
 
+#if USE_HCACHE
+int mh_sync_mailbox_message (CONTEXT * ctx, int msgno, header_cache_t *hc)
+#else
+int mh_sync_mailbox_message (CONTEXT * ctx, int msgno)
+#endif
+{
+    char path[_POSIX_PATH_MAX], tmp[_POSIX_PATH_MAX];
+    HEADER *h = ctx->hdrs[msgno];
+
+    if (h->deleted && (ctx->magic != MUTT_MAILDIR || !option (OPTMAILDIRTRASH)))
+    {
+      snprintf (path, sizeof (path), "%s/%s", ctx->path, h->path);
+      if (ctx->magic == MUTT_MAILDIR
+	  || (option (OPTMHPURGE) && ctx->magic == MUTT_MH))
+      {
+#if USE_HCACHE
+	if (hc) {
+           if (ctx->magic == MUTT_MAILDIR)
+              mutt_hcache_delete (hc, h->path + 3, &maildir_hcache_keylen);
+	   else if (ctx->magic == MUTT_MH)
+	      mutt_hcache_delete (hc, h->path, strlen);
+	}
+#endif /* USE_HCACHE */
+	unlink (path);
+      }
+      else if (ctx->magic == MUTT_MH)
+      {
+	/* MH just moves files out of the way when you delete them */
+	if (*h->path != ',')
+	{
+	  snprintf (tmp, sizeof (tmp), "%s/,%s", ctx->path, h->path);
+	  unlink (tmp);
+	  rename (path, tmp);
+	}
+
+      }
+    }
+    else if (h->changed || h->attach_del ||
+	     h->xlabel_changed ||
+	     (ctx->magic == MUTT_MAILDIR
+	      && (option (OPTMAILDIRTRASH) || h->trash)
+	      && (h->deleted != h->trash)))
+    {
+      if (ctx->magic == MUTT_MAILDIR)
+      {
+	if (maildir_sync_message (ctx, msgno) == -1)
+	  return -1;
+      }
+      else
+      {
+	if (mh_sync_message (ctx, msgno) == -1)
+	  return -1;
+      }
+    }
+
+#if USE_HCACHE
+    if (hc && h->changed)
+    {
+      if (ctx->magic == MUTT_MAILDIR)
+	mutt_hcache_store (hc, h->path + 3, h, 0, &maildir_hcache_keylen, MUTT_GENERATE_UIDVALIDITY);
+      else if (ctx->magic == MUTT_MH)
+	mutt_hcache_store (hc, h->path, h, 0, strlen, MUTT_GENERATE_UIDVALIDITY);
+    }
+#endif
+
+    return 0;
+}
+
 int mh_sync_mailbox (CONTEXT * ctx, int *index_hint)
 {
-  char path[_POSIX_PATH_MAX], tmp[_POSIX_PATH_MAX];
   int i, j;
 #if USE_HCACHE
   header_cache_t *hc = NULL;
@@ -1876,9 +1971,9 @@ int mh_sync_mailbox (CONTEXT * ctx, int 
 
   if (ctx->magic == MUTT_MH)
     i = mh_check_mailbox (ctx, index_hint);
-  else 
+  else
     i = maildir_check_mailbox (ctx, index_hint);
-      
+
   if (i != 0)
     return i;
 
@@ -1898,61 +1993,12 @@ int mh_sync_mailbox (CONTEXT * ctx, int 
     if (!ctx->quiet)
       mutt_progress_update (&progress, i, -1);
 
-    if (ctx->hdrs[i]->deleted
-	&& (ctx->magic != MUTT_MAILDIR || !option (OPTMAILDIRTRASH)))
-    {
-      snprintf (path, sizeof (path), "%s/%s", ctx->path, ctx->hdrs[i]->path);
-      if (ctx->magic == MUTT_MAILDIR
-	  || (option (OPTMHPURGE) && ctx->magic == MUTT_MH))
-      {
 #if USE_HCACHE
-        if (ctx->magic == MUTT_MAILDIR)
-          mutt_hcache_delete (hc, ctx->hdrs[i]->path + 3, &maildir_hcache_keylen);
-	else if (ctx->magic == MUTT_MH)
-	  mutt_hcache_delete (hc, ctx->hdrs[i]->path, strlen);
-#endif /* USE_HCACHE */
-	unlink (path);
-      }
-      else if (ctx->magic == MUTT_MH)
-      {
-	/* MH just moves files out of the way when you delete them */
-	if (*ctx->hdrs[i]->path != ',')
-	{
-	  snprintf (tmp, sizeof (tmp), "%s/,%s", ctx->path,
-		    ctx->hdrs[i]->path);
-	  unlink (tmp);
-	  rename (path, tmp);
-	}
-
-      }
-    }
-    else if (ctx->hdrs[i]->changed || ctx->hdrs[i]->attach_del ||
-	     ctx->hdrs[i]->xlabel_changed ||
-	     (ctx->magic == MUTT_MAILDIR
-	      && (option (OPTMAILDIRTRASH) || ctx->hdrs[i]->trash)
-	      && (ctx->hdrs[i]->deleted != ctx->hdrs[i]->trash)))
-    {
-      if (ctx->magic == MUTT_MAILDIR)
-      {
-	if (maildir_sync_message (ctx, i) == -1)
-	  goto err;
-      }
-      else
-      {
-	if (mh_sync_message (ctx, i) == -1)
-	  goto err;
-      }
-    }
-
-#if USE_HCACHE
-    if (ctx->hdrs[i]->changed)
-    {
-      if (ctx->magic == MUTT_MAILDIR)
-	mutt_hcache_store (hc, ctx->hdrs[i]->path + 3, ctx->hdrs[i],
-			   0, &maildir_hcache_keylen, MUTT_GENERATE_UIDVALIDITY);
-      else if (ctx->magic == MUTT_MH)
-	mutt_hcache_store (hc, ctx->hdrs[i]->path, ctx->hdrs[i], 0, strlen, MUTT_GENERATE_UIDVALIDITY);
-    }
+    if (mh_sync_mailbox_message (ctx, i, hc) == -1)
+      goto err;
+#else
+    if (mh_sync_mailbox_message (ctx, i) == -1)
+      goto err;
 #endif
 
   }
@@ -2033,7 +2079,7 @@ static void maildir_update_tables (CONTE
   mutt_clear_threads (ctx);
 }
 
-static int maildir_update_flags (CONTEXT *ctx, HEADER *o, HEADER *n)
+int maildir_update_flags (CONTEXT *ctx, HEADER *o, HEADER *n)
 {
   /* save the global state here so we can reset it at the
    * end of list block if required.
@@ -2359,7 +2405,7 @@ static int mh_check_mailbox (CONTEXT * c
  */
 
 static FILE *_maildir_open_find_message (const char *folder, const char *unique,
-				  const char *subfolder)
+				  const char *subfolder, char **newname)
 {
   char dir[_POSIX_PATH_MAX];
   char tunique[_POSIX_PATH_MAX];
@@ -2395,11 +2441,15 @@ static FILE *_maildir_open_find_message 
 
   closedir (dp);
 
+  if (newname && fp)
+    *newname = safe_strdup(fname);
+
   errno = oe;
   return fp;
 }
 
-FILE *maildir_open_find_message (const char *folder, const char *msg)
+FILE *maildir_open_find_message (const char *folder, const char *msg,
+                                  char **newname)
 {
   char unique[_POSIX_PATH_MAX];
   FILE *fp;
@@ -2411,7 +2461,8 @@ FILE *maildir_open_find_message (const c
   if (
       (fp =
        _maildir_open_find_message (folder, unique,
-				   new_hits > cur_hits ? "new" : "cur"))
+				   new_hits > cur_hits ? "new" : "cur",
+				   newname))
       || errno != ENOENT)
   {
     if (new_hits < UINT_MAX && cur_hits < UINT_MAX)
@@ -2425,7 +2476,8 @@ FILE *maildir_open_find_message (const c
   if (
       (fp =
        _maildir_open_find_message (folder, unique,
-				   new_hits > cur_hits ? "cur" : "new"))
+				   new_hits > cur_hits ? "cur" : "new",
+				   newname))
       || errno != ENOENT)
   {
     if (new_hits < UINT_MAX && cur_hits < UINT_MAX)
diff -r dd070f9b9ecd -r b19cab9fe4ad mutt.h
--- a/mutt.h	Sat Mar 31 14:15:41 2018 +0200
+++ b/mutt.h	Sat Mar 31 14:15:43 2018 +0200
@@ -102,6 +102,10 @@
 #define  MUTT_COMMAND (1<<6) /* do command completion */
 #define  MUTT_PATTERN (1<<7) /* pattern mode - only used for history classes */
 #define  MUTT_LABEL   (1<<8) /* do label completion */
+#if USE_NOTMUCH
+#define  MUTT_NM_QUERY (1<<9) /* Notmuch query mode. */
+#define  MUTT_NM_TAG   (1<<10) /* Notmuch tag +/- mode. */
+#endif
 
 /* flags for mutt_get_token() */
 #define MUTT_TOKEN_EQUAL      1       /* treat '=' as a special */
@@ -248,6 +252,9 @@ enum
   MUTT_CRYPT_ENCRYPT,
   MUTT_PGP_KEY,
   MUTT_XLABEL,
+#ifdef USE_NOTMUCH
+  MUTT_NOTMUCH_LABEL,
+#endif
   MUTT_MIMEATTACH,
 #ifdef USE_NNTP
   MUTT_NEWSGROUPS,
@@ -340,6 +347,7 @@ enum
 #define MUTT_SEL_BUFFY  (1<<0)
 #define MUTT_SEL_MULTI  (1<<1)
 #define MUTT_SEL_FOLDER (1<<2)
+#define MUTT_SEL_VFOLDER	(1<<3)
 
 /* flags for parse_spam_list */
 #define MUTT_SPAM          1
@@ -593,6 +601,11 @@ enum
   OPTNEWSSEND,		/* (pseudo) used to change behavior when posting */
 #endif
 
+#ifdef USE_NOTMUCH
+  OPTVIRTSPOOLFILE,
+  OPTNOTMUCHRECORD,
+#endif
+
   OPTMAX
 };
 
@@ -868,9 +881,12 @@ typedef struct header
   int refno;			/* message number on server */
 #endif
 
-#if defined USE_POP || defined USE_IMAP || defined USE_NNTP
+#if defined USE_POP || defined USE_IMAP || defined USE_NNTP || defined USE_NOTMUCH
   void *data;            	/* driver-specific data */
 #endif
+#if defined USE_NOTMUCH
+  void (*free_cb)(struct header *); /* driver-specific data free function */
+#endif
   
   char *maildir_flags;		/* unknown maildir flags */
 } HEADER;
diff -r dd070f9b9ecd -r b19cab9fe4ad mutt_curses.h
--- a/mutt_curses.h	Sat Mar 31 14:15:41 2018 +0200
+++ b/mutt_curses.h	Sat Mar 31 14:15:43 2018 +0200
@@ -133,6 +133,10 @@ enum
   MT_COLOR_INDEX_LABEL,
   MT_COLOR_INDEX_NUMBER,
   MT_COLOR_INDEX_SIZE,
+#ifdef USE_NOTMUCH
+  MT_COLOR_INDEX_TAG,
+  MT_COLOR_INDEX_TAGS,
+#endif
   MT_COLOR_COMPOSE_HEADER,
   MT_COLOR_COMPOSE_SECURITY_ENCRYPT,
   MT_COLOR_COMPOSE_SECURITY_SIGN,
@@ -226,6 +230,10 @@ extern COLOR_LINE *ColorIndexAuthorList;
 extern COLOR_LINE *ColorIndexFlagsList;
 extern COLOR_LINE *ColorIndexSubjectList;
 
+#ifdef USE_NOTMUCH
+extern COLOR_LINE *ColorIndexTagList;
+#endif
+
 void ci_init_color (void);
 void ci_start_color (void);
 
diff -r dd070f9b9ecd -r b19cab9fe4ad mutt_notmuch.c
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/mutt_notmuch.c	Sat Mar 31 14:15:43 2018 +0200
@@ -0,0 +1,2108 @@
+/*
+ * Notmuch support for mutt
+ *
+ * Copyright (C) 2011, 2012 Karel Zak <kzak@redhat.com>
+ *
+ * Notes:
+ *
+ * - notmuch uses private CONTEXT->data and private HEADER->data
+ *
+ * - all exported functions are usable within notmuch context only
+ *
+ * - all functions have to be covered by "ctx->magic == MUTT_NOTMUCH" check
+ *   (it's implemented in get_ctxdata() and init_context() functions).
+ *
+ * - exception are nm_nonctx_* functions -- these functions use nm_default_uri
+ *   (or parse URI from another resource)
+ */
+#if HAVE_CONFIG_H
+# include "config.h"
+#endif
+
+#include "mutt.h"
+#include "mx.h"
+#include "rfc2047.h"
+#include "sort.h"
+#include "mailbox.h"
+#include "copy.h"
+#include "keymap.h"
+#include "url.h"
+#include "buffy.h"
+
+#include <dirent.h>
+#include <fcntl.h>
+#include <sys/file.h>
+#include <sys/stat.h>
+#include <errno.h>
+#include <unistd.h>
+#include <stdlib.h>
+#include <string.h>
+#include <ctype.h>
+#include <utime.h>
+
+#include <notmuch.h>
+
+#include "mutt_notmuch.h"
+#include "mutt_curses.h"
+
+#ifdef LIBNOTMUCH_CHECK_VERSION
+#undef LIBNOTMUCH_CHECK_VERSION
+#endif
+
+/* The definition in <notmuch.h> is broken */
+#define LIBNOTMUCH_CHECK_VERSION(major, minor, micro)                               \
+    (LIBNOTMUCH_MAJOR_VERSION > (major) ||                                          \
+     (LIBNOTMUCH_MAJOR_VERSION == (major) && LIBNOTMUCH_MINOR_VERSION > (minor)) || \
+     (LIBNOTMUCH_MAJOR_VERSION == (major) && LIBNOTMUCH_MINOR_VERSION == (minor) && \
+      LIBNOTMUCH_MICRO_VERSION >= (micro)))
+
+
+/* read whole-thread or matching messages only? */
+enum {
+	NM_QUERY_TYPE_MESGS = 1,	/* default */
+	NM_QUERY_TYPE_THREADS
+};
+
+/*
+ * Parsed URI arguments
+ */
+struct uri_tag {
+	char *name;
+	char *value;
+	struct uri_tag *next;
+};
+
+/*
+ * HEADER->(nm_hdrdata *)data->tag_list node
+ */
+struct nm_hdrtag
+{
+  char *tag;
+  char *transformed;
+  struct nm_hdrtag *next;
+};
+
+/*
+ * HEADER->data
+ */
+struct nm_hdrdata {
+	char *folder;
+	char *tags;
+	char *tags_transformed;
+	struct nm_hdrtag *tag_list;
+	char *oldpath;
+	char *virtual_id;
+	int magic;
+};
+
+/*
+ * CONTEXT->data
+ */
+struct nm_ctxdata {
+	notmuch_database_t *db;
+
+	char *db_filename;
+	char *db_query;
+	int db_limit;
+	int query_type;
+
+	struct uri_tag *query_items;
+
+	progress_t progress;
+	int oldmsgcount;
+	int ignmsgcount;	/* ingored messages */
+
+	unsigned int noprogress : 1,
+		     longrun : 1,
+		     trans : 1,
+		     progress_ready : 1;
+
+};
+
+static HEADER *get_mutt_header(CONTEXT *ctx, notmuch_message_t *msg);
+static notmuch_message_t *get_nm_message(notmuch_database_t *db, HEADER *hdr);
+
+static void url_free_tags(struct uri_tag *tags)
+{
+	while (tags) {
+		struct uri_tag *next = tags->next;
+		FREE(&tags->name);
+		FREE(&tags->value);
+		FREE(&tags);
+		tags = next;
+	}
+}
+
+static int url_parse_query(char *url, char **filename, struct uri_tag **tags)
+{
+	char *p = strstr(url, "://");	/* remote unsupported */
+	char *e;
+	char c;
+	struct uri_tag *tag, *last = NULL;
+
+	*filename = NULL;
+	*tags = NULL;
+
+	if (!p || !*(p + 3))
+		return -1;
+
+	p += 3;
+	e = strchr(p, '?');
+	if (e) {
+		if (e != p) {
+			*e = '\0';
+			*filename = safe_strdup(p);
+			*e = '?';
+		} else {
+			*filename = NULL;
+		}
+	} else {
+		*filename = safe_strdup(p);
+		return 0;
+	}
+
+	if (*filename && url_pct_decode(*filename) < 0)
+		goto err;
+	if (!e)
+		return 0;	/* only filename */
+
+	++e;	/* skip '?' */
+	p = e;
+
+	while (p && *p) {
+		tag = safe_calloc(1, sizeof(struct uri_tag));
+		if (!tag)
+			goto err;
+
+		if (!*tags)
+			last = *tags = tag;
+		else {
+			last->next = tag;
+			last = tag;
+		}
+
+		c = '=';
+		e = strchr(p, c);
+		if (!e) {
+			c = '&';
+			e = strchr(p, c);
+		}
+		if (e)
+			*e = '\0';
+		tag->name = safe_strdup(p);
+		if (e)
+			*e = c;
+		if (!tag->name || url_pct_decode(tag->name) < 0)
+			goto err;
+		if (!e)
+			break;
+
+		p = e + 1;
+
+		if (*e == '&')
+			continue;
+
+		e = strchr(p, '&');
+		if (e)
+			*e = '\0';
+		tag->value = safe_strdup(p);
+		if (e)
+			*e = '&';
+		if (!tag->value || url_pct_decode(tag->value) < 0)
+			goto err;
+		if (!e)
+			break;
+		p = e + 1;
+	}
+
+	return 0;
+err:
+	FREE(&(*filename));
+	url_free_tags(*tags);
+	return -1;
+}
+
+static void free_tag_list(struct nm_hdrtag **tag_list)
+{
+	struct nm_hdrtag *tmp;
+
+	while ((tmp = *tag_list) != NULL)
+	{
+		*tag_list = tmp->next;
+		FREE(&tmp->tag);
+		FREE(&tmp->transformed);
+		FREE(&tmp);
+	}
+
+	*tag_list = 0;
+}
+
+static void free_hdrdata(struct nm_hdrdata *data)
+{
+	if (!data)
+		return;
+
+	dprint(2, (debugfile, "nm: freeing header %p\n", data));
+	FREE(&data->folder);
+	FREE(&data->tags);
+	FREE(&data->tags_transformed);
+	free_tag_list(&data->tag_list);
+	FREE(&data->oldpath);
+	FREE(&data->virtual_id);
+	FREE(&data);
+}
+
+static void free_ctxdata(struct nm_ctxdata *data)
+{
+	if (!data)
+		return;
+
+	dprint(1, (debugfile, "nm: freeing context data %p\n", data));
+
+	if (data->db)
+#ifdef NOTMUCH_API_3
+	        notmuch_database_destroy(data->db);
+#else
+		notmuch_database_close(data->db);
+#endif
+	data->db = NULL;
+
+	FREE(&data->db_filename);
+	FREE(&data->db_query);
+	url_free_tags(data->query_items);
+	FREE(&data);
+}
+
+static struct nm_ctxdata *new_ctxdata(char *uri)
+{
+	struct nm_ctxdata *data;
+
+	if (!uri)
+		return NULL;
+
+	data = safe_calloc(1, sizeof(struct nm_ctxdata));
+	dprint(1, (debugfile, "nm: initialize context data %p\n", data));
+
+	data->db_limit = NotmuchDBLimit;
+
+	if (url_parse_query(uri, &data->db_filename, &data->query_items)) {
+		mutt_error(_("failed to parse notmuch uri: %s"), uri);
+		data->db_filename = NULL;
+		data->query_items = NULL;
+		data->query_type = 0;
+		return NULL;
+	}
+
+	return data;
+}
+
+static int deinit_context(CONTEXT *ctx)
+{
+	int i;
+
+	if (!ctx || ctx->magic != MUTT_NOTMUCH)
+		return -1;
+
+	for (i = 0; i < ctx->msgcount; i++) {
+		HEADER *h = ctx->hdrs[i];
+
+		if (h) {
+			free_hdrdata(h->data);
+			h->data = NULL;
+		}
+	}
+
+	free_ctxdata(ctx->data);
+	ctx->data = NULL;
+	return 0;
+}
+
+static int init_context(CONTEXT *ctx)
+{
+	if (!ctx || ctx->magic != MUTT_NOTMUCH)
+		return -1;
+
+	if (ctx->data)
+		return 0;
+
+	ctx->data = new_ctxdata(ctx->path);
+	if (!ctx->data)
+		return -1;
+
+	return 0;
+}
+
+char *nm_header_get_folder(HEADER *h)
+{
+	return h && h->data ? ((struct nm_hdrdata *) h->data)->folder : NULL;
+}
+
+/* returns all unhidden tags */
+char *nm_header_get_tags(HEADER *h)
+{
+	return h && h->data ? ((struct nm_hdrdata *) h->data)->tags : NULL;
+}
+
+char *nm_header_get_tags_transformed(HEADER *h)
+{
+	return h && h->data ? ((struct nm_hdrdata *) h->data)->tags_transformed : NULL;
+}
+
+char *nm_header_get_tag_transformed(char *tag, HEADER *h)
+{
+	struct nm_hdrtag *tmp;
+
+	if (!h || !h->data)
+		return NULL;
+
+	for (tmp = ((struct nm_hdrdata *) h->data)->tag_list;
+	     tmp != NULL;
+	     tmp = tmp->next)
+	{
+		if (strcmp(tag, tmp->tag) == 0)
+			return tmp->transformed;
+	}
+
+	return NULL;
+}
+
+int nm_header_get_magic(HEADER *h)
+{
+	return h && h->data ? ((struct nm_hdrdata *) h->data)->magic : 0;
+}
+
+/*
+ * Returns notmuch message Id.
+ */
+static char *nm_header_get_id(HEADER *h)
+{
+	return h && h->data ? ((struct nm_hdrdata *) h->data)->virtual_id : NULL;
+}
+
+
+char *nm_header_get_fullpath(HEADER *h, char *buf, size_t bufsz)
+{
+	snprintf(buf, bufsz, "%s/%s", nm_header_get_folder(h), h->path);
+	/*dprint(2, (debugfile, "nm: returns fullpath '%s'\n", buf));*/
+	return buf;
+}
+
+
+static struct nm_ctxdata *get_ctxdata(CONTEXT *ctx)
+{
+	if (ctx && ctx->magic == MUTT_NOTMUCH)
+		return ctx->data;
+
+	return NULL;
+}
+
+static int string_to_guery_type(const char *str)
+{
+	if (!str)
+		str = NotmuchQueryType;		/* user's default */
+	if (!str)
+		return NM_QUERY_TYPE_MESGS;	/* hardcoded default */
+
+	if (strcmp(str, "threads") == 0)
+		return NM_QUERY_TYPE_THREADS;
+	else if (strcmp(str, "messages") == 0)
+		return NM_QUERY_TYPE_MESGS;
+
+	mutt_error (_("failed to parse notmuch query type: %s"), str);
+	return NM_QUERY_TYPE_MESGS;
+}
+
+static char *get_query_string(struct nm_ctxdata *data)
+{
+	struct uri_tag *item;
+
+	if (!data)
+		return NULL;
+	if (data->db_query)
+		return data->db_query;
+
+	for (item = data->query_items; item; item = item->next) {
+		if (!item->value || !item->name)
+			continue;
+
+		if (strcmp(item->name, "limit") == 0) {
+			if (mutt_atoi(item->value, &data->db_limit))
+				mutt_error (_("failed to parse notmuch limit: %s"), item->value);
+
+		} else if (strcmp(item->name, "type") == 0)
+			data->query_type = string_to_guery_type(item->value);
+
+		else if (strcmp(item->name, "query") == 0)
+			data->db_query = safe_strdup(item->value);
+	}
+
+	if (!data->query_type)
+		data->query_type = string_to_guery_type(NULL);
+
+	dprint(2, (debugfile, "nm: query '%s'\n", data->db_query));
+
+	return data->db_query;
+}
+
+static int get_limit(struct nm_ctxdata *data)
+{
+	return data ? data->db_limit : 0;
+}
+
+static int get_query_type(struct nm_ctxdata *data)
+{
+	return (data && data->query_type) ? data->query_type : string_to_guery_type(NULL);
+}
+
+static const char *get_db_filename(struct nm_ctxdata *data)
+{
+	char *db_filename;
+
+	if (!data)
+		return NULL;
+
+	db_filename = data->db_filename ? data->db_filename : NotmuchDefaultUri;
+	if (!db_filename)
+		db_filename = Maildir;
+	if (!db_filename)
+		return NULL;
+	if (strncmp(db_filename, "notmuch://", 10) == 0)
+		db_filename += 10;
+
+	dprint(2, (debugfile, "nm: db filename '%s'\n", db_filename));
+	return db_filename;
+}
+
+static notmuch_database_t *do_database_open(const char *filename,
+					    int writable, int verbose)
+{
+	notmuch_database_t *db = NULL;
+	unsigned int ct = 0;
+	notmuch_status_t st = NOTMUCH_STATUS_SUCCESS;
+
+	dprint(1, (debugfile, "nm: db open '%s' %s (timeout %d)\n", filename,
+			writable ? "[WRITE]" : "[READ]", NotmuchOpenTimeout));
+	do {
+#ifdef NOTMUCH_API_3
+		st = notmuch_database_open(filename,
+					writable ? NOTMUCH_DATABASE_MODE_READ_WRITE :
+					NOTMUCH_DATABASE_MODE_READ_ONLY, &db);
+#else
+		db = notmuch_database_open(filename,
+					writable ? NOTMUCH_DATABASE_MODE_READ_WRITE :
+					NOTMUCH_DATABASE_MODE_READ_ONLY);
+#endif
+		if (db || !NotmuchOpenTimeout || ct / 2 > NotmuchOpenTimeout)
+			break;
+
+		if (verbose && ct && ct % 2 == 0)
+			mutt_error(_("Waiting for notmuch DB... (%d sec)"), ct / 2);
+		usleep(500000);
+		ct++;
+	} while (1);
+
+	if (verbose) {
+		if (!db)
+			mutt_error (_("Cannot open notmuch database: %s: %s"),
+				    filename,
+				    st ? notmuch_status_to_string(st) :
+					 _("unknown reason"));
+		else if (ct > 1)
+			mutt_clear_error();
+	}
+	return db;
+}
+
+static notmuch_database_t *get_db(struct nm_ctxdata *data, int writable)
+{
+	if (!data)
+	       return NULL;
+	if (!data->db) {
+		const char *db_filename = get_db_filename(data);
+
+		if (db_filename)
+			data->db = do_database_open(db_filename, writable, TRUE);
+	}
+	return data->db;
+}
+
+static int release_db(struct nm_ctxdata *data)
+{
+	if (data && data->db) {
+		dprint(1, (debugfile, "nm: db close\n"));
+#ifdef NOTMUCH_API_3
+		notmuch_database_destroy(data->db);
+#else
+		notmuch_database_close(data->db);
+#endif
+		data->db = NULL;
+		data->longrun = 0;
+		return 0;
+	}
+
+	return -1;
+}
+
+/* returns:	< 0 = error
+ *		  1 = new transaction started
+ *		  0 = already within transaction
+ */
+static int db_trans_begin(struct nm_ctxdata *data)
+{
+	if (!data || !data->db)
+		return -1;
+
+	if (!data->trans) {
+		dprint(2, (debugfile, "nm: db trans start\n"));
+		if (notmuch_database_begin_atomic(data->db))
+			return -1;
+		data->trans = 1;
+		return 1;
+	}
+
+	return 0;
+}
+
+static int db_trans_end(struct nm_ctxdata *data)
+{
+	if (!data || !data->db)
+		return -1;
+
+	if (data->trans) {
+		dprint(2, (debugfile, "nm: db trans end\n"));
+		data->trans = 0;
+		if (notmuch_database_end_atomic(data->db))
+			return -1;
+	}
+
+	return 0;
+}
+
+void nm_longrun_init(CONTEXT *ctx, int writable)
+{
+	struct nm_ctxdata *data = get_ctxdata(ctx);
+
+	if (data && get_db(data, writable)) {
+		data->longrun = 1;
+		dprint(2, (debugfile, "nm: long run initialized\n"));
+	}
+}
+
+void nm_longrun_done(CONTEXT *ctx)
+{
+	struct nm_ctxdata *data = get_ctxdata(ctx);
+
+	if (data && release_db(data) == 0)
+		dprint(2, (debugfile, "nm: long run deinitialized\n"));
+}
+
+static int is_longrun(struct nm_ctxdata *data)
+{
+	return data && data->longrun;
+}
+
+void nm_debug_check(CONTEXT *ctx)
+{
+	struct nm_ctxdata *data = get_ctxdata(ctx);
+
+	if (!data)
+		return;
+
+	if (data->db) {
+		dprint(1, (debugfile, "nm: ERROR: db is open, closing\n"));
+		release_db(data);
+	}
+}
+
+static int get_database_mtime(struct nm_ctxdata *data, time_t *mtime)
+{
+	char path[_POSIX_PATH_MAX];
+	struct stat st;
+
+	if (!data)
+	       return -1;
+
+	snprintf(path, sizeof(path), "%s/.notmuch/xapian", get_db_filename(data));
+	dprint(2, (debugfile, "nm: checking '%s' mtime\n", path));
+
+	if (stat(path, &st))
+		return -1;
+
+	if (mtime)
+		*mtime = st.st_mtime;
+
+	return 0;
+}
+
+static void apply_exclude_tags(notmuch_query_t *query)
+{
+	char *buf, *p, *end = NULL, *tag = NULL;
+
+	if (!NotmuchExcludeTags || !*NotmuchExcludeTags)
+		return;
+	buf = safe_strdup(NotmuchExcludeTags);
+
+	for (p = buf; p && *p; p++) {
+		if (!tag && isspace(*p))
+			continue;
+		if (!tag)
+			tag = p;		/* begin of the tag */
+		if (*p == ',' || *p == ' ')
+			end = p;		/* terminate the tag */
+		else if (*(p + 1) == '\0')
+			end = p + 1;		/* end of optstr */
+		if (!tag || !end)
+			continue;
+		if (tag >= end)
+			break;
+		*end = '\0';
+
+		dprint(2, (debugfile, "nm: query exclude tag '%s'\n", tag));
+		notmuch_query_add_tag_exclude(query, tag);
+		end = tag = NULL;
+	}
+	notmuch_query_set_omit_excluded(query, 1);
+	FREE(&buf);
+}
+
+static notmuch_query_t *get_query(struct nm_ctxdata *data, int writable)
+{
+	notmuch_database_t *db = NULL;
+	notmuch_query_t *q = NULL;
+	const char *str;
+
+	if (!data)
+		return NULL;
+
+	db = get_db(data, writable);
+	str = get_query_string(data);
+
+	if (!db || !str)
+		goto err;
+
+	q = notmuch_query_create(db, str);
+	if (!q)
+		goto err;
+
+	apply_exclude_tags(q);
+	notmuch_query_set_sort(q, NOTMUCH_SORT_NEWEST_FIRST);
+	dprint(2, (debugfile, "nm: query successfully initialized\n"));
+	return q;
+err:
+	if (!is_longrun(data))
+		release_db(data);
+	return NULL;
+}
+
+static void append_str_item(char **str, const char *item, int sep)
+{
+	char *p;
+	size_t sz = strlen(item);
+	size_t ssz = *str ? strlen(*str) : 0;
+
+	safe_realloc(str, ssz + (ssz && sep ? 1 : 0) + sz + 1);
+	p = *str + ssz;
+	if (sep && ssz)
+	    *p++ = sep;
+	memcpy(p, item, sz + 1);
+}
+
+static int update_header_tags(HEADER *h, notmuch_message_t *msg)
+{
+	struct nm_hdrdata *data = h->data;
+	notmuch_tags_t *tags;
+	char *tstr = NULL, *ttstr = NULL;
+	struct nm_hdrtag *tag_list = NULL, *tmp;
+
+	dprint(2, (debugfile, "nm: tags update requested (%s)\n", data->virtual_id));
+
+	for (tags = notmuch_message_get_tags(msg);
+	     tags && notmuch_tags_valid(tags);
+	     notmuch_tags_move_to_next(tags)) {
+
+		const char *t = notmuch_tags_get(tags);
+		const char *tt = NULL;
+
+		if (!t || !*t)
+			continue;
+
+		tt = hash_find(TagTransforms, t);
+		if (!tt)
+			tt = t;
+
+		/* tags list contains all tags */
+		tmp = safe_calloc(1, sizeof(*tmp));
+		tmp->tag = safe_strdup(t);
+		tmp->transformed = safe_strdup(tt);
+		tmp->next = tag_list;
+		tag_list = tmp;
+
+		/* filter out hidden tags */
+		if (NotmuchHiddenTags) {
+			char *p = strstr(NotmuchHiddenTags, t);
+			size_t xsz = p ? strlen(t) : 0;
+
+			if (p && (p == NotmuchHiddenTags
+				  || *(p - 1) == ','
+				  || *(p - 1) == ' ')
+			    && (*(p + xsz) == '\0'
+				  || *(p + xsz) == ','
+				  || *(p + xsz) == ' '))
+				continue;
+		}
+
+		/* expand the transformed tag string */
+		append_str_item(&ttstr, tt, ' ');
+
+		/* expand the un-transformed tag string */
+		append_str_item(&tstr, t, ' ');
+	}
+
+	free_tag_list(&data->tag_list);
+	data->tag_list = tag_list;
+
+	if (data->tags && tstr && strcmp(data->tags, tstr) == 0) {
+		FREE(&tstr);
+		FREE(&ttstr);
+		dprint(2, (debugfile, "nm: tags unchanged\n"));
+		return 1;
+	}
+
+	/* free old version */
+	FREE(&data->tags);
+	FREE(&data->tags_transformed);
+
+	/* new version */
+	data->tags = tstr;
+	dprint(2, (debugfile, "nm: new tags: '%s'\n", tstr));
+
+	data->tags_transformed = ttstr;
+	dprint(2, (debugfile, "nm: new tag transforms: '%s'\n", ttstr));
+
+	return 0;
+}
+
+/*
+ * set/update HEADER->path and HEADER->data->path
+ */
+static int update_message_path(HEADER *h, const char *path)
+{
+	struct nm_hdrdata *data = h->data;
+	char *p;
+	size_t len;
+
+	dprint(2, (debugfile, "nm: path update requested path=%s, (%s)\n",
+				path, data->virtual_id));
+
+	p = strrchr(path, '/');
+	if (p && p - path > 3 &&
+	    (strncmp(p - 3, "cur", 3) == 0 ||
+	     strncmp(p - 3, "new", 3) == 0 ||
+	     strncmp(p - 3, "tmp", 3) == 0)) {
+
+		data->magic = MUTT_MAILDIR;
+
+		FREE(&h->path);
+		FREE(&data->folder);
+
+		p -= 3;				/* skip subfolder (e.g. "new") */
+		h->path = safe_strdup(p);
+
+		for (; p > path && *(p - 1) == '/'; p--);
+
+		len = p - path;
+		data->folder = safe_malloc(len + 1);
+		memcpy(data->folder, path, len);
+		data->folder[len] = '\0';
+
+		dprint(2, (debugfile, "nm: folder='%s', file='%s'\n", data->folder, h->path));
+		return 0;
+	}
+
+	return 1;
+}
+
+static char *get_folder_from_path(const char *path)
+{
+	char *p = strrchr(path, '/');
+	char *ret;
+	size_t len;
+
+	if (p && p - path > 3 &&
+	    (strncmp(p - 3, "cur", 3) == 0 ||
+	     strncmp(p - 3, "new", 3) == 0 ||
+	     strncmp(p - 3, "tmp", 3) == 0)) {
+
+		p -= 3;
+		for (; p > path && *(p - 1) == '/'; p--);
+
+		len = p - path;
+		ret = safe_malloc(len + 1);
+		memcpy(ret, path, len);
+		ret[len] = '\0';
+		return ret;
+	}
+
+	return NULL;
+}
+
+static void deinit_header(HEADER *h)
+{
+	if (h) {
+		free_hdrdata(h->data);
+		h->data = NULL;
+	}
+}
+
+/* converts notmuch message Id to mutt message <Id> */
+static char *nm2mutt_message_id(const char *id)
+{
+	size_t sz;
+	char *mid;
+
+	if (!id)
+		return NULL;
+	sz = strlen(id) + 3;
+	mid = safe_malloc(sz);
+
+	snprintf(mid, sz, "<%s>", id);
+	return mid;
+}
+
+static int init_header(HEADER *h, const char *path, notmuch_message_t *msg)
+{
+	const char *id;
+
+	if (h->data)
+		return 0;
+
+	id = notmuch_message_get_message_id(msg);
+
+	h->data = safe_calloc(1, sizeof(struct nm_hdrdata));
+	h->free_cb = deinit_header;
+
+	/*
+	 * Notmuch ensures that message Id exists (if not notmuch Notmuch will
+	 * generate an ID), so it's more safe than use mutt HEADER->env->id
+	 */
+	((struct nm_hdrdata *) h->data)->virtual_id = safe_strdup( id );
+
+	dprint(2, (debugfile, "nm: initialize header data: [hdr=%p, data=%p] (%s)\n",
+				h, h->data, id));
+
+	if (!h->env->message_id)
+		h->env->message_id = nm2mutt_message_id( id );
+
+	if (update_message_path(h, path))
+		return -1;
+
+	update_header_tags(h, msg);
+
+	return 0;
+}
+
+/**
+static void debug_print_filenames(notmuch_message_t *msg)
+{
+	notmuch_filenames_t *ls;
+	const char *id = notmuch_message_get_message_id(msg);
+
+	for (ls = notmuch_message_get_filenames(msg);
+	     ls && notmuch_filenames_valid(ls);
+	     notmuch_filenames_move_to_next(ls)) {
+
+		dprint(2, (debugfile, "nm: %s: %s\n", id, notmuch_filenames_get(ls)));
+	}
+}
+
+static void debug_print_tags(notmuch_message_t *msg)
+{
+	notmuch_tags_t *tags;
+	const char *id = notmuch_message_get_message_id(msg);
+
+	for (tags = notmuch_message_get_tags(msg);
+	     tags && notmuch_tags_valid(tags);
+	     notmuch_tags_move_to_next(tags)) {
+
+		dprint(2, (debugfile, "nm: %s: %s\n", id, notmuch_tags_get(tags)));
+	}
+}
+***/
+
+static const char *get_message_last_filename(notmuch_message_t *msg)
+{
+	notmuch_filenames_t *ls;
+	const char *name = NULL;
+
+	for (ls = notmuch_message_get_filenames(msg);
+	     ls && notmuch_filenames_valid(ls);
+	     notmuch_filenames_move_to_next(ls)) {
+
+		name = notmuch_filenames_get(ls);
+	}
+
+	return name;
+}
+
+static void nm_progress_reset(CONTEXT *ctx)
+{
+	struct nm_ctxdata *data;
+
+	if (ctx->quiet)
+		return;
+
+	data = get_ctxdata(ctx);
+
+	memset(&data->progress, 0, sizeof(data->progress));
+	data->oldmsgcount = ctx->msgcount;
+	data->ignmsgcount = 0;
+	data->noprogress = 0;
+	data->progress_ready = 0;
+}
+
+static void nm_progress_update(CONTEXT *ctx, notmuch_query_t *q)
+{
+	struct nm_ctxdata *data = get_ctxdata(ctx);
+
+	if (ctx->quiet || data->noprogress)
+		return;
+
+	if (!data->progress_ready && q) {
+		unsigned count;
+		static char msg[STRING];
+		snprintf(msg, sizeof(msg), _("Reading messages..."));
+
+#if LIBNOTMUCH_CHECK_VERSION(4,3,0)
+		if (notmuch_query_count_messages_st (q, &count) != NOTMUCH_STATUS_SUCCESS)
+			count = 0;	/* may not be defined on error */
+#else
+		count = notmuch_query_count_messages(q);
+#endif
+		mutt_progress_init(&data->progress, msg, MUTT_PROGRESS_MSG,
+			ReadInc, count);
+		data->progress_ready = 1;
+	}
+
+	if (data->progress_ready)
+		mutt_progress_update(&data->progress,
+				ctx->msgcount + data->ignmsgcount
+					      - data->oldmsgcount, -1);
+}
+
+static void append_message(CONTEXT *ctx,
+			   notmuch_query_t *q,
+			   notmuch_message_t *msg,
+			   int dedup)
+{
+	char *newpath = NULL;
+	const char *path;
+	HEADER *h = NULL;
+
+	/* deduplicate */
+	if (dedup && get_mutt_header(ctx, msg)) {
+		get_ctxdata(ctx)->ignmsgcount++;
+		nm_progress_update(ctx, q);
+	        dprint(2, (debugfile, "nm: ignore id=%s, already in the context\n",
+					notmuch_message_get_message_id(msg)));
+		return;
+	}
+
+	path = get_message_last_filename(msg);
+	if (!path)
+		return;
+
+	dprint(2, (debugfile, "nm: appending message, i=%d, id=%s, path=%s\n",
+				ctx->msgcount,
+				notmuch_message_get_message_id(msg),
+				path));
+
+	if (ctx->msgcount >= ctx->hdrmax) {
+		dprint(2, (debugfile, "nm: allocate mx memory\n"));
+		mx_alloc_memory(ctx);
+	}
+	if (access(path, F_OK) == 0)
+		h = maildir_parse_message(MUTT_MAILDIR, path, 0, NULL);
+	else {
+		/* maybe moved try find it... */
+		char *folder = get_folder_from_path(path);
+
+		if (folder) {
+			FILE *f = maildir_open_find_message(folder, path, &newpath);
+			if (f) {
+				h = maildir_parse_stream(MUTT_MAILDIR, f, newpath, 0, NULL);
+				fclose(f);
+
+				dprint(1, (debugfile, "nm: not up-to-date: %s -> %s\n",
+							path, newpath));
+			}
+		}
+		FREE(&folder);
+	}
+
+	if (!h) {
+		dprint(1, (debugfile, "nm: failed to parse message: %s\n", path));
+		goto done;
+	}
+	if (init_header(h, newpath ? newpath : path, msg) != 0) {
+		mutt_free_header(&h);
+		dprint(1, (debugfile, "nm: failed to append header!\n"));
+		goto done;
+	}
+
+	h->active = 1;
+	h->index = ctx->msgcount;
+	ctx->size += h->content->length
+		   + h->content->offset
+		   - h->content->hdr_offset;
+	ctx->hdrs[ctx->msgcount] = h;
+	ctx->msgcount++;
+
+	if (newpath) {
+		/* remember that file has been moved -- nm_sync() will update the DB */
+		struct nm_hdrdata *hd = (struct nm_hdrdata *) h->data;
+
+		if (hd) {
+			dprint(1, (debugfile, "nm: remember obsolete path: %s\n", path));
+			hd->oldpath = safe_strdup(path);
+		}
+	}
+	nm_progress_update(ctx, q);
+done:
+	FREE(&newpath);
+}
+
+/*
+ * add all the replies to a given messages into the display.
+ * Careful, this calls itself recursively to make sure we get
+ * everything.
+ */
+static void append_replies(CONTEXT *ctx,
+			   notmuch_query_t *q,
+			   notmuch_message_t *top,
+			   int dedup)
+{
+	notmuch_messages_t *msgs;
+
+	for (msgs = notmuch_message_get_replies(top);
+	     notmuch_messages_valid(msgs);
+	     notmuch_messages_move_to_next(msgs)) {
+
+		notmuch_message_t *m = notmuch_messages_get(msgs);
+		append_message(ctx, q, m, dedup);
+		/* recurse through all the replies to this message too */
+		append_replies(ctx, q, m, dedup);
+		notmuch_message_destroy(m);
+	}
+}
+
+/*
+ * add each top level reply in the thread, and then add each
+ * reply to the top level replies
+ */
+static void append_thread(CONTEXT *ctx,
+			  notmuch_query_t *q,
+			  notmuch_thread_t *thread,
+			  int dedup)
+{
+	notmuch_messages_t *msgs;
+
+	for (msgs = notmuch_thread_get_toplevel_messages(thread);
+	     notmuch_messages_valid(msgs);
+	     notmuch_messages_move_to_next(msgs)) {
+
+		notmuch_message_t *m = notmuch_messages_get(msgs);
+		append_message(ctx, q, m, dedup);
+		append_replies(ctx, q, m, dedup);
+		notmuch_message_destroy(m);
+	}
+}
+
+static void read_mesgs_query(CONTEXT *ctx, notmuch_query_t *q, int dedup)
+{
+	struct nm_ctxdata *data = get_ctxdata(ctx);
+	int limit;
+	notmuch_messages_t *msgs;
+
+	if (!data)
+		return;
+
+	limit = get_limit(data);
+
+#if LIBNOTMUCH_CHECK_VERSION(4,3,0)
+	if (notmuch_query_search_messages_st (q, &msgs) != NOTMUCH_STATUS_SUCCESS)
+		return;
+#else
+	msgs = notmuch_query_search_messages(q);
+#endif
+
+	for (; notmuch_messages_valid(msgs) &&
+		(limit == 0 || ctx->msgcount < limit);
+	     notmuch_messages_move_to_next(msgs)) {
+
+		notmuch_message_t *m = notmuch_messages_get(msgs);
+		append_message(ctx, q, m, dedup);
+		notmuch_message_destroy(m);
+	}
+}
+
+static void read_threads_query(CONTEXT *ctx, notmuch_query_t *q, int dedup, int limit)
+{
+	struct nm_ctxdata *data = get_ctxdata(ctx);
+	notmuch_threads_t *threads;
+
+	if (!data)
+		return;
+
+#if LIBNOTMUCH_CHECK_VERSION(4,3,0)
+	if (notmuch_query_search_threads_st (q, &threads) != NOTMUCH_STATUS_SUCCESS)
+		return;
+#else
+	threads = notmuch_query_search_threads(q);
+#endif
+
+	for (; notmuch_threads_valid(threads) &&
+		(limit == 0 || ctx->msgcount < limit);
+	     notmuch_threads_move_to_next(threads)) {
+
+		notmuch_thread_t *thread = notmuch_threads_get(threads);
+		append_thread(ctx, q, thread, dedup);
+		notmuch_thread_destroy(thread);
+	}
+}
+
+int nm_read_query(CONTEXT *ctx)
+{
+	notmuch_query_t *q;
+	struct nm_ctxdata *data;
+	int rc = -1;
+
+	if (init_context(ctx) != 0)
+		return -1;
+
+	data = get_ctxdata(ctx);
+	if (!data)
+		return -1;
+
+	dprint(1, (debugfile, "nm: reading messages...[current count=%d]\n",
+				ctx->msgcount));
+
+	nm_progress_reset(ctx);
+
+	q = get_query(data, FALSE);
+	if (q) {
+		switch(get_query_type(data)) {
+		case NM_QUERY_TYPE_MESGS:
+			read_mesgs_query(ctx, q, 0);
+			break;
+		case NM_QUERY_TYPE_THREADS:
+			read_threads_query(ctx, q, 0, get_limit(data));
+			break;
+		}
+		notmuch_query_destroy(q);
+		rc = 0;
+
+	}
+
+	if (!is_longrun(data))
+		release_db(data);
+
+	ctx->mtime = time(NULL);
+
+	mx_update_context(ctx, ctx->msgcount);
+	data->oldmsgcount = 0;
+
+	dprint(1, (debugfile, "nm: reading messages... done [rc=%d, count=%d]\n",
+				rc, ctx->msgcount));
+	return rc;
+}
+
+int nm_read_entire_thread(CONTEXT *ctx, HEADER *h)
+{
+	struct nm_ctxdata *data = get_ctxdata(ctx);
+	const char *id;
+	char *qstr = NULL;
+	notmuch_query_t *q = NULL;
+	notmuch_database_t *db = NULL;
+	notmuch_message_t *msg = NULL;
+	int rc = -1;
+
+	if (!data)
+		return -1;
+	if (!(db = get_db(data, FALSE)) || !(msg = get_nm_message(db, h)))
+		goto done;
+
+	dprint(1, (debugfile, "nm: reading entire-thread messages...[current count=%d]\n",
+				ctx->msgcount));
+
+	nm_progress_reset(ctx);
+	id = notmuch_message_get_thread_id(msg);
+	if (!id)
+		goto done;
+	append_str_item(&qstr, "thread:", 0);
+	append_str_item(&qstr, id, 0);
+
+	q = notmuch_query_create(db, qstr);
+	FREE(&qstr);
+	if (!q)
+		goto done;
+	apply_exclude_tags(q);
+	notmuch_query_set_sort(q, NOTMUCH_SORT_NEWEST_FIRST);
+
+	read_threads_query(ctx, q, 1, 0);
+	ctx->mtime = time(NULL);
+	rc = 0;
+
+	if (ctx->msgcount > data->oldmsgcount)
+		mx_update_context(ctx, ctx->msgcount - data->oldmsgcount);
+done:
+	if (q)
+		notmuch_query_destroy(q);
+	if (!is_longrun(data))
+		release_db(data);
+
+	if (ctx->msgcount == data->oldmsgcount)
+		mutt_message _("No more messages in the thread.");
+
+	data->oldmsgcount = 0;
+	dprint(1, (debugfile, "nm: reading entire-thread messages... done [rc=%d, count=%d]\n",
+				rc, ctx->msgcount));
+	return rc;
+}
+
+char *nm_uri_from_query(CONTEXT *ctx, char *buf, size_t bufsz)
+{
+	struct nm_ctxdata *data = get_ctxdata(ctx);
+	char uri[_POSIX_PATH_MAX + LONG_STRING + 32];	/* path to DB + query + URI "decoration" */
+
+	if (data)
+		snprintf(uri, sizeof(uri), "notmuch://%s?query=%s",
+			 get_db_filename(data), buf);
+	else if (NotmuchDefaultUri)
+		snprintf(uri, sizeof(uri), "%s?query=%s", NotmuchDefaultUri, buf);
+	else if (Maildir)
+		snprintf(uri, sizeof(uri), "notmuch://%s?query=%s", Maildir, buf);
+	else
+		return NULL;
+
+	strncpy(buf, uri, bufsz);
+	buf[bufsz - 1] = '\0';
+
+	dprint(1, (debugfile, "nm: uri from query '%s'\n", buf));
+	return buf;
+}
+
+/*
+ * returns message from notmuch database
+ */
+static notmuch_message_t *get_nm_message(notmuch_database_t *db, HEADER *hdr)
+{
+	notmuch_message_t *msg = NULL;
+	char *id = nm_header_get_id(hdr);
+
+	dprint(2, (debugfile, "nm: find message (%s)\n", id));
+
+	if (id && db)
+		notmuch_database_find_message(db, id, &msg);
+
+	return msg;
+}
+
+static int update_tags(notmuch_message_t *msg, const char *tags)
+{
+	char *tag = NULL, *end = NULL, *p;
+	char *buf = safe_strdup(tags);
+
+	if (!buf)
+		return -1;
+
+	notmuch_message_freeze(msg);
+
+	for (p = buf; p && *p; p++) {
+		if (!tag && isspace(*p))
+			continue;
+		if (!tag)
+			tag = p;		/* begin of the tag */
+		if (*p == ',' || *p == ' ')
+			end = p;		/* terminate the tag */
+		else if (*(p + 1) == '\0')
+			end = p + 1;		/* end of optstr */
+		if (!tag || !end)
+			continue;
+		if (tag >= end)
+			break;
+
+		*end = '\0';
+
+		if (*tag == '-') {
+			dprint(1, (debugfile, "nm: remove tag: '%s'\n", tag + 1));
+			notmuch_message_remove_tag(msg, tag + 1);
+		} else {
+			dprint(1, (debugfile, "nm: add tag: '%s'\n", *tag == '+' ? tag + 1 : tag));
+			notmuch_message_add_tag(msg, *tag == '+' ? tag + 1 : tag);
+		}
+		end = tag = NULL;
+	}
+
+	notmuch_message_thaw(msg);
+	FREE(&buf);
+	return 0;
+}
+
+/* TODO: extract parsing of string to separate function, join
+ * update_header_tags and update_header_flags, which are given an array of
+ * tags. */
+static int update_header_flags(CONTEXT *ctx, HEADER *hdr, const char *tags)
+{
+	char *tag = NULL, *end = NULL, *p;
+	char *buf = safe_strdup(tags);
+
+	if (!buf)
+		return -1;
+
+	for (p = buf; p && *p; p++) {
+		if (!tag && isspace(*p))
+			continue;
+		if (!tag)
+			tag = p;		/* begin of the tag */
+		if (*p == ',' || *p == ' ')
+			end = p;		/* terminate the tag */
+		else if (*(p + 1) == '\0')
+			end = p + 1;		/* end of optstr */
+		if (!tag || !end)
+			continue;
+		if (tag >= end)
+			break;
+
+		*end = '\0';
+
+		if (*tag == '-') {
+			tag = tag + 1;
+			if (strcmp(tag, "unread") == 0)
+				mutt_set_flag (ctx, hdr, MUTT_READ, 1);
+			else if (strcmp(tag, "replied") == 0)
+				mutt_set_flag (ctx, hdr, MUTT_REPLIED, 0);
+			else if (strcmp(tag, "flagged") == 0)
+				mutt_set_flag (ctx, hdr, MUTT_FLAG, 0);
+		} else {
+			tag = *tag == '+' ? tag + 1 : tag;
+			if (strcmp(tag, "unread") == 0)
+				mutt_set_flag (ctx, hdr, MUTT_READ, 0);
+			else if (strcmp(tag, "replied") == 0)
+				mutt_set_flag (ctx, hdr, MUTT_REPLIED, 1);
+			else if (strcmp(tag, "flagged") == 0)
+				mutt_set_flag (ctx, hdr, MUTT_FLAG, 1);
+		}
+		end = tag = NULL;
+	}
+
+	FREE(&buf);
+	return 0;
+}
+
+int nm_modify_message_tags(CONTEXT *ctx, HEADER *hdr, char *buf)
+{
+	struct nm_ctxdata *data = get_ctxdata(ctx);
+	notmuch_database_t *db = NULL;
+	notmuch_message_t *msg = NULL;
+	int rc = -1;
+
+	if (!buf || !*buf || !data)
+		return -1;
+
+	if (!(db = get_db(data, TRUE)) || !(msg = get_nm_message(db, hdr)))
+		goto done;
+
+	dprint(1, (debugfile, "nm: tags modify: '%s'\n", buf));
+
+	update_tags(msg, buf);
+	update_header_flags(ctx, hdr, buf);
+	update_header_tags(hdr, msg);
+	mutt_set_header_color(ctx, hdr);
+
+	rc = 0;
+	hdr->changed = TRUE;
+done:
+	if (!is_longrun(data))
+		release_db(data);
+	if (hdr->changed)
+		ctx->mtime = time(NULL);
+	dprint(1, (debugfile, "nm: tags modify done [rc=%d]\n", rc));
+	return rc;
+}
+
+static int rename_maildir_filename(const char *old, char *newpath, size_t newsz, HEADER *h)
+{
+	char filename[_POSIX_PATH_MAX];
+	char suffix[_POSIX_PATH_MAX];
+	char folder[_POSIX_PATH_MAX];
+	char *p;
+
+	strfcpy(folder, old, sizeof(folder));
+	p = strrchr(folder, '/');
+	if (p)
+		*p = '\0';
+
+	p++;
+	strfcpy(filename, p, sizeof(filename));
+
+	/* remove (new,cur,...) from folder path */
+	p = strrchr(folder, '/');
+	if (p)
+		*p = '\0';
+
+	/* remove old flags from filename */
+	if ((p = strchr(filename, ':')))
+		*p = '\0';
+
+	/* compose new flags */
+	maildir_flags(suffix, sizeof(suffix), h);
+
+	snprintf(newpath, newsz, "%s/%s/%s%s",
+			folder,
+			(h->read || h->old) ? "cur" : "new",
+			filename,
+			suffix);
+
+	if (strcmp(old, newpath) == 0)
+		return 1;
+
+	if (rename(old, newpath) != 0) {
+		dprint(1, (debugfile, "nm: rename(2) failed %s -> %s\n", old, newpath));
+		return -1;
+	}
+
+	return 0;
+}
+
+static int remove_filename(struct nm_ctxdata *data, const char *path)
+{
+	notmuch_status_t st;
+	notmuch_filenames_t *ls;
+	notmuch_message_t *msg = NULL;
+	notmuch_database_t *db = get_db(data, TRUE);
+	int trans;
+
+	dprint(2, (debugfile, "nm: remove filename '%s'\n", path));
+
+	if (!db)
+		return -1;
+	st = notmuch_database_find_message_by_filename(db, path, &msg);
+	if (st || !msg)
+		return -1;
+	trans = db_trans_begin(data);
+	if (trans < 0)
+		return -1;
+
+	/*
+	 * note that unlink() is probably unnecessary here, it's already removed
+	 * by mh_sync_mailbox_message(), but for sure...
+	 */
+	st = notmuch_database_remove_message(db, path);
+	switch (st) {
+	case NOTMUCH_STATUS_SUCCESS:
+		dprint(2, (debugfile, "nm: remove success, call unlink\n"));
+		unlink(path);
+		break;
+	case NOTMUCH_STATUS_DUPLICATE_MESSAGE_ID:
+		dprint(2, (debugfile, "nm: remove success (duplicate), call unlink\n"));
+		unlink(path);
+		for (ls = notmuch_message_get_filenames(msg);
+		     ls && notmuch_filenames_valid(ls);
+		     notmuch_filenames_move_to_next(ls)) {
+
+			path = notmuch_filenames_get(ls);
+
+			dprint(2, (debugfile, "nm: remove duplicate: '%s'\n", path));
+			unlink(path);
+			notmuch_database_remove_message(db, path);
+		}
+		break;
+	default:
+		dprint(1, (debugfile, "nm: failed to remove '%s' [st=%d]\n", path, (int) st));
+		break;
+	}
+
+	notmuch_message_destroy(msg);
+	if (trans)
+		db_trans_end(data);
+	return 0;
+}
+
+static int rename_filename(struct nm_ctxdata *data,
+			const char *old, const char *new, HEADER *h)
+{
+	int rc = -1;
+	notmuch_status_t st;
+	notmuch_filenames_t *ls;
+	notmuch_message_t *msg;
+	notmuch_database_t *db = get_db(data, TRUE);
+	int trans;
+
+	if (!db || !new || !old || access(new, F_OK) != 0)
+		return -1;
+
+	dprint(1, (debugfile, "nm: rename filename, %s -> %s\n", old, new));
+	trans = db_trans_begin(data);
+	if (trans < 0)
+		return -1;
+
+	dprint(2, (debugfile, "nm: rename: add '%s'\n", new));
+	st = notmuch_database_add_message(db, new, &msg);
+
+	if (st != NOTMUCH_STATUS_SUCCESS &&
+	    st != NOTMUCH_STATUS_DUPLICATE_MESSAGE_ID) {
+		dprint(1, (debugfile, "nm: failed to add '%s' [st=%d]\n", new, (int) st));
+		goto done;
+	}
+
+	dprint(2, (debugfile, "nm: rename: rem '%s'\n", old));
+	st = notmuch_database_remove_message(db, old);
+	switch (st) {
+	case NOTMUCH_STATUS_SUCCESS:
+		break;
+	case NOTMUCH_STATUS_DUPLICATE_MESSAGE_ID:
+		dprint(2, (debugfile, "nm: rename: syncing duplicate filename\n"));
+		notmuch_message_destroy(msg);
+		msg = NULL;
+		notmuch_database_find_message_by_filename(db, new, &msg);
+
+		for (ls = notmuch_message_get_filenames(msg);
+		     msg && ls && notmuch_filenames_valid(ls);
+		     notmuch_filenames_move_to_next(ls)) {
+
+			const char *path = notmuch_filenames_get(ls);
+			char newpath[_POSIX_PATH_MAX];
+
+			if (strcmp(new, path) == 0)
+				continue;
+
+			dprint(2, (debugfile, "nm: rename: syncing duplicate: %s\n", path));
+
+			if (rename_maildir_filename(path, newpath, sizeof(newpath), h) == 0) {
+				dprint(2, (debugfile, "nm: rename dup %s -> %s\n", path, newpath));
+				notmuch_database_remove_message(db, path);
+				notmuch_database_add_message(db, newpath, NULL);
+			}
+		}
+		notmuch_message_destroy(msg);
+		msg = NULL;
+		notmuch_database_find_message_by_filename(db, new, &msg);
+		st = NOTMUCH_STATUS_SUCCESS;
+		break;
+	default:
+		dprint(1, (debugfile, "nm: failed to remove '%s' [st=%d]\n",
+					old, (int) st));
+		break;
+	}
+
+	if (st == NOTMUCH_STATUS_SUCCESS && h && msg) {
+		notmuch_message_maildir_flags_to_tags(msg);
+		update_header_tags(h, msg);
+		update_tags(msg, nm_header_get_tags(h));
+	}
+
+	rc = 0;
+done:
+	if (msg)
+		notmuch_message_destroy(msg);
+	if (trans)
+		db_trans_end(data);
+	return rc;
+}
+
+int nm_update_filename(CONTEXT *ctx, const char *old, const char *new, HEADER *h)
+{
+	char buf[PATH_MAX];
+	int rc;
+	struct nm_ctxdata *data = get_ctxdata(ctx);
+
+	if (!data || !new)
+		return -1;
+
+	if (!old && h && h->data) {
+		nm_header_get_fullpath(h, buf, sizeof(buf));
+		old = buf;
+	}
+
+	rc = rename_filename(data, old, new, h);
+
+	if (!is_longrun(data))
+		release_db(data);
+	ctx->mtime = time(NULL);
+	return rc;
+}
+
+int nm_sync(CONTEXT *ctx, int *index_hint)
+{
+	struct nm_ctxdata *data = get_ctxdata(ctx);
+	int i, rc = 0;
+	char msgbuf[STRING];
+	progress_t progress;
+	char *uri = ctx->path;
+	int changed = 0;
+
+	if (!data)
+		return -1;
+
+	dprint(1, (debugfile, "nm: sync start ...\n"));
+
+	if (!ctx->quiet) {
+		/* all is in this function so we don't use data->progress here */
+		snprintf(msgbuf, sizeof (msgbuf), _("Writing %s..."), ctx->path);
+		mutt_progress_init(&progress, msgbuf, MUTT_PROGRESS_MSG,
+				   WriteInc, ctx->msgcount);
+	}
+
+	for (i = 0; i < ctx->msgcount; i++) {
+		char old[_POSIX_PATH_MAX], new[_POSIX_PATH_MAX];
+		HEADER *h = ctx->hdrs[i];
+		struct nm_hdrdata *hd = h->data;
+
+		if (!ctx->quiet)
+			mutt_progress_update(&progress, i, -1);
+
+		*old = *new = '\0';
+
+		if (hd->oldpath) {
+			strncpy(old, hd->oldpath, sizeof(old));
+			old[sizeof(old) - 1] = '\0';
+			dprint(2, (debugfile, "nm: fixing obsolete path '%s'\n", old));
+		} else
+			nm_header_get_fullpath(h, old, sizeof(old));
+
+		ctx->path = hd->folder;
+		ctx->magic = hd->magic;
+#if USE_HCACHE
+		rc = mh_sync_mailbox_message(ctx, i, NULL);
+#else
+		rc = mh_sync_mailbox_message(ctx, i);
+#endif
+		ctx->path = uri;
+		ctx->magic = MUTT_NOTMUCH;
+
+		if (rc)
+			break;
+
+		if (!h->deleted)
+			nm_header_get_fullpath(h, new, sizeof(new));
+
+		if (h->deleted || strcmp(old, new) != 0) {
+			if (h->deleted && remove_filename(data, old) == 0)
+				changed = 1;
+			else if (*new && *old && rename_filename(data, old, new, h) == 0)
+				changed = 1;
+		}
+
+		FREE(&hd->oldpath);
+	}
+
+	ctx->path = uri;
+	ctx->magic = MUTT_NOTMUCH;
+
+	if (!is_longrun(data))
+		release_db(data);
+	if (changed)
+		ctx->mtime = time(NULL);
+
+	dprint(1, (debugfile, "nm: .... sync done [rc=%d]\n", rc));
+	return rc;
+}
+
+static unsigned count_query(notmuch_database_t *db, const char *qstr)
+{
+	unsigned res = 0;
+	notmuch_query_t *q = notmuch_query_create(db, qstr);
+
+	if (q) {
+		apply_exclude_tags(q);
+#if LIBNOTMUCH_CHECK_VERSION(4,3,0)
+		if (notmuch_query_count_messages_st (q, &res) != NOTMUCH_STATUS_SUCCESS)
+			res = 0;	/* may not be defined on error */
+#else
+		res = notmuch_query_count_messages(q);
+#endif
+		notmuch_query_destroy(q);
+		dprint(1, (debugfile, "nm: count '%s', result=%d\n", qstr, res));
+	}
+	return res;
+}
+
+int nm_nonctx_get_count(char *path, int *all, int *new)
+{
+	struct uri_tag *query_items = NULL, *item;
+	char *db_filename = NULL, *db_query = NULL;
+	notmuch_database_t *db = NULL;
+	int rc = -1, dflt = 0;
+
+	dprint(1, (debugfile, "nm: count\n"));
+
+	if (url_parse_query(path, &db_filename, &query_items)) {
+		mutt_error(_("failed to parse notmuch uri: %s"), path);
+		goto done;
+	}
+	if (!query_items)
+		goto done;
+
+	for (item = query_items; item; item = item->next) {
+		if (item->value && strcmp(item->name, "query") == 0) {
+			db_query = item->value;
+			break;
+		}
+	}
+
+	if (!db_query)
+		goto done;
+
+	if (!db_filename) {
+		if (NotmuchDefaultUri) {
+			if (strncmp(NotmuchDefaultUri, "notmuch://", 10) == 0)
+				db_filename = NotmuchDefaultUri + 10;
+			else
+				db_filename = NotmuchDefaultUri;
+		} else if (Maildir)
+			db_filename = Maildir;
+		dflt = 1;
+	}
+
+	/* don't be verbose about connection, as we're called from
+	 * sidebar/buffy very often */
+	db = do_database_open(db_filename, FALSE, FALSE);
+	if (!db)
+		goto done;
+
+	/* all emails */
+	if (all)
+		*all = count_query(db, db_query);
+
+	/* new messages */
+	if (new) {
+		char *qstr;
+
+		safe_asprintf(&qstr, "( %s ) tag:%s",
+				db_query, NotmuchUnreadTag);
+		*new = count_query(db, qstr);
+		FREE(&qstr);
+	}
+
+	rc = 0;
+done:
+	if (db) {
+#ifdef NOTMUCH_API_3
+		notmuch_database_destroy(db);
+#else
+		notmuch_database_close(db);
+#endif
+		dprint(1, (debugfile, "nm: count close DB\n"));
+	}
+	if (!dflt)
+		FREE(&db_filename);
+	url_free_tags(query_items);
+
+	dprint(1, (debugfile, "nm: count done [rc=%d]\n", rc));
+	return rc;
+}
+
+char *nm_get_description(CONTEXT *ctx)
+{
+	BUFFY *p;
+
+	for (p = VirtIncoming; p; p = p->next)
+		if (p->desc && strcmp(p->path, ctx->path) == 0)
+			return p->desc;
+
+	return NULL;
+}
+
+int nm_description_to_path(const char *desc, char *buf, size_t bufsz)
+{
+	BUFFY *p;
+
+	if (!desc || !buf || !bufsz)
+		return -EINVAL;
+
+	for (p = VirtIncoming; p; p = p->next)
+		if (p->desc && strcmp(desc, p->desc) == 0) {
+			strncpy(buf, p->path, bufsz);
+			buf[bufsz - 1] = '\0';
+			return 0;
+		}
+
+	return -1;
+}
+
+/*
+ * returns header from mutt context
+ */
+static HEADER *get_mutt_header(CONTEXT *ctx, notmuch_message_t *msg)
+{
+	char *mid;
+	const char *id;
+	HEADER *h;
+
+	if (!ctx || !msg)
+		return NULL;
+
+	id = notmuch_message_get_message_id(msg);
+	if (!id)
+		return NULL;
+
+	dprint(2, (debugfile, "nm: mutt header, id='%s'\n", id));
+
+	if (!ctx->id_hash) {
+		dprint(2, (debugfile, "nm: init hash\n"));
+		ctx->id_hash = mutt_make_id_hash(ctx);
+		if (!ctx->id_hash)
+			return NULL;
+	}
+
+	mid = nm2mutt_message_id( id );
+	dprint(2, (debugfile, "nm: mutt id='%s'\n", mid));
+
+	h = hash_find(ctx->id_hash, mid);
+	FREE(&mid);
+	return h;
+}
+
+static int nm_check_database(CONTEXT *ctx, int *index_hint)
+{
+	struct nm_ctxdata *data = get_ctxdata(ctx);
+	time_t mtime = 0;
+	notmuch_query_t *q;
+	notmuch_messages_t *msgs;
+	int i, limit, occult = 0, new_flags = 0;
+
+	if (!data || get_database_mtime(data, &mtime) != 0)
+		return -1;
+
+	if (ctx->mtime >= mtime) {
+		dprint(2, (debugfile, "nm: check unnecessary (db=%d ctx=%d)\n", mtime, ctx->mtime));
+		return 0;
+	}
+
+	dprint(1, (debugfile, "nm: checking (db=%d ctx=%d)\n", mtime, ctx->mtime));
+
+	q = get_query(data, FALSE);
+	if (!q)
+		goto done;
+
+	dprint(1, (debugfile, "nm: start checking (count=%d)\n", ctx->msgcount));
+	data->oldmsgcount = ctx->msgcount;
+	data->noprogress = 1;
+
+	for (i = 0; i < ctx->msgcount; i++)
+		ctx->hdrs[i]->active = 0;
+
+	limit = get_limit(data);
+
+#if LIBNOTMUCH_CHECK_VERSION(4,3,0)
+	if (notmuch_query_search_messages_st (q, &msgs) != NOTMUCH_STATUS_SUCCESS)
+		goto done;
+#else
+	msgs = notmuch_query_search_messages(q);
+#endif
+
+	for (i = 0;
+	     notmuch_messages_valid(msgs) && (limit == 0 || i < limit);
+	     notmuch_messages_move_to_next(msgs), i++) {
+
+		char old[_POSIX_PATH_MAX];
+		const char *new;
+
+		notmuch_message_t *m = notmuch_messages_get(msgs);
+		HEADER *h = get_mutt_header(ctx, m);
+
+		if (!h) {
+			/* new email */
+			append_message(ctx, NULL, m, 0);
+			notmuch_message_destroy(m);
+			continue;
+		}
+
+		/* message already exists, merge flags */
+		h->active = 1;
+
+		/* check to see if the message has moved to a different
+		 * subdirectory.  If so, update the associated filename.
+		 */
+		new = get_message_last_filename(m);
+		nm_header_get_fullpath(h, old, sizeof(old));
+
+		if (mutt_strcmp(old, new) != 0)
+			update_message_path(h, new);
+
+		if (!h->changed) {
+			/* if the user hasn't modified the flags on
+			 * this message, update the flags we just
+			 * detected.
+			 */
+			HEADER tmp;
+			memset(&tmp, 0, sizeof(tmp));
+			maildir_parse_flags(&tmp, new);
+			(void) maildir_update_flags(ctx, h, &tmp);
+		}
+
+		if (update_header_tags(h, m) == 0)
+			new_flags++;
+
+		notmuch_message_destroy(m);
+	}
+
+	for (i = 0; i < ctx->msgcount; i++) {
+		if (ctx->hdrs[i]->active == 0) {
+			occult = 1;
+			break;
+		}
+	}
+
+	if (ctx->msgcount > data->oldmsgcount)
+		mx_update_context(ctx, ctx->msgcount - data->oldmsgcount);
+done:
+	if (q)
+		notmuch_query_destroy(q);
+
+	if (!is_longrun(data))
+		release_db(data);
+
+	ctx->mtime = time(NULL);
+
+	dprint(1, (debugfile, "nm: ... check done [count=%d, new_flags=%d, occult=%d]\n",
+				ctx->msgcount, new_flags, occult));
+
+	return occult ? MUTT_REOPENED :
+	       ctx->msgcount > data->oldmsgcount ? MUTT_NEW_MAIL :
+	       new_flags ? MUTT_FLAGS : 0;
+}
+
+int nm_record_message(CONTEXT *ctx, char *path, HEADER *h)
+{
+	notmuch_database_t *db;
+	notmuch_status_t st;
+	notmuch_message_t *msg = NULL;
+	int rc = -1, trans;
+	struct nm_ctxdata *data = get_ctxdata(ctx);
+
+	if (!path || !data || access(path, F_OK) != 0)
+		return 0;
+	db = get_db(data, TRUE);
+	if (!db)
+		return -1;
+
+	dprint(1, (debugfile, "nm: record message: %s\n", path));
+	trans = db_trans_begin(data);
+	if (trans < 0)
+		goto done;
+
+	st = notmuch_database_add_message(db, path, &msg);
+
+	if (st != NOTMUCH_STATUS_SUCCESS &&
+	    st != NOTMUCH_STATUS_DUPLICATE_MESSAGE_ID) {
+		dprint(1, (debugfile, "nm: failed to add '%s' [st=%d]\n", path, (int) st));
+		goto done;
+	}
+
+	if (st == NOTMUCH_STATUS_SUCCESS && msg) {
+		notmuch_message_maildir_flags_to_tags(msg);
+		if (h)
+			update_tags(msg, nm_header_get_tags(h));
+		if (NotmuchRecordTags)
+			update_tags(msg, NotmuchRecordTags);
+	}
+
+	rc = 0;
+done:
+	if (msg)
+		notmuch_message_destroy(msg);
+	if (trans == 1)
+		db_trans_end(data);
+	if (!is_longrun(data))
+		release_db(data);
+	return rc;
+}
+
+/*
+ * Fill a list with all notmuch tags.
+ *
+ * If tag_list is NULL, just count the tags.
+ */
+int nm_get_all_tags(CONTEXT *ctx, char **tag_list, int *tag_count)
+{
+	struct nm_ctxdata *data = get_ctxdata(ctx);
+	notmuch_database_t *db = NULL;
+	notmuch_tags_t *tags = NULL;
+	int rc = -1;
+
+	if (!data)
+		return -1;
+
+	if (!(db = get_db(data, FALSE)) ||
+			!(tags = notmuch_database_get_all_tags(db)))
+		goto done;
+
+	*tag_count = 0;
+	dprint(1, (debugfile, "nm: get all tags\n"));
+
+	while (notmuch_tags_valid(tags)) {
+		if (tag_list != NULL) {
+			tag_list[*tag_count] = safe_strdup(notmuch_tags_get(tags));
+		}
+		(*tag_count)++;
+		notmuch_tags_move_to_next(tags);
+	}
+
+	rc = 0;
+done:
+	if (tags)
+		notmuch_tags_destroy(tags);
+
+	if (!is_longrun(data))
+		release_db(data);
+
+	dprint(1, (debugfile, "nm: get all tags done [rc=%d tag_count=%u]\n", rc,
+						 *tag_count));
+	return rc;
+}
+
+static int nm_open_message (CONTEXT *ctx, MESSAGE *msg, int msgno)
+{
+	if (!ctx || !msg)
+		return 1;
+	HEADER *cur = ctx->hdrs[msgno];
+	char *folder = ctx->path;
+	char path[_POSIX_PATH_MAX];
+	folder = nm_header_get_folder(cur);
+
+	snprintf (path, sizeof (path), "%s/%s", folder, cur->path);
+
+	msg->fp = fopen (path, "r");
+	if ((msg->fp == NULL) && (errno == ENOENT) && ((ctx->magic == MUTT_MAILDIR) || (ctx->magic == MUTT_NOTMUCH)))
+		msg->fp = maildir_open_find_message (folder, cur->path, NULL);
+
+	dprint(1, (debugfile, "%s\n", __func__));
+	return 0;
+}
+
+static int nm_close_message (CONTEXT *ctx, MESSAGE *msg)
+{
+	if (!msg)
+		return 1;
+	safe_fclose (&(msg->fp));
+	return 0;
+}
+
+static int nm_commit_message (CONTEXT *ctx, MESSAGE *msg)
+{
+	mutt_perror _("Can't write to virtual folder.");
+	return 1;
+}
+
+struct mx_ops mx_notmuch_ops = {
+	.open         = nm_read_query,	/* calls init_context() */
+	.open_append  = NULL,
+	.close        = deinit_context,
+	.check        = nm_check_database,
+	.open_msg     = nm_open_message,
+	.close_msg    = nm_close_message,
+	.commit_msg   = nm_commit_message,
+	.open_new_msg = NULL,
+	.sync         = nm_sync,
+};
diff -r dd070f9b9ecd -r b19cab9fe4ad mutt_notmuch.h
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/mutt_notmuch.h	Sat Mar 31 14:15:43 2018 +0200
@@ -0,0 +1,40 @@
+/*
+ * Copyright (C) 2011 Karel Zak <kzak@redhat.com>
+ */
+#ifndef _MUTT_NOTMUCH_H_
+#define _MUTT_NOTMUCH_H_ 1
+
+int nm_read_query(CONTEXT *ctx);
+int nm_read_entire_thread(CONTEXT *ctx, HEADER *h);
+
+int nm_sync(CONTEXT * ctx, int *index_hint);
+char *nm_header_get_folder(HEADER *h);
+int nm_header_get_magic(HEADER *h);
+char *nm_header_get_fullpath(HEADER *h, char *buf, size_t bufsz);
+int nm_update_filename(CONTEXT *ctx, const char *o, const char *n, HEADER *h);
+char *nm_uri_from_query(CONTEXT *ctx, char *buf, size_t bufsz);
+int nm_modify_message_tags(CONTEXT *ctx, HEADER *hdr, char *tags);
+
+void nm_longrun_init(CONTEXT *cxt, int writable);
+void nm_longrun_done(CONTEXT *cxt);
+
+char *nm_get_description(CONTEXT *ctx);
+int nm_description_to_path(const char *desc, char *buf, size_t bufsz);
+
+int nm_record_message(CONTEXT *ctx, char *path, HEADER *h);
+
+void nm_debug_check(CONTEXT *ctx);
+int nm_get_all_tags(CONTEXT *ctx, char **tag_list, int *tag_count);
+
+/*
+ * functions usable outside notmuch CONTEXT
+ */
+int nm_nonctx_get_count(char *path, int *all, int *new);
+
+char *nm_header_get_tag_transformed(char *tag, HEADER *h);
+char *nm_header_get_tags_transformed(HEADER *h);
+char *nm_header_get_tags(HEADER *h);
+
+extern struct mx_ops mx_notmuch_ops;
+
+#endif /* _MUTT_NOTMUCH_H_ */
diff -r dd070f9b9ecd -r b19cab9fe4ad muttlib.c
--- a/muttlib.c	Sat Mar 31 14:15:41 2018 +0200
+++ b/muttlib.c	Sat Mar 31 14:15:43 2018 +0200
@@ -32,6 +32,10 @@
 #include "imap.h"
 #endif
 
+#ifdef USE_NOTMUCH
+#include "mutt_notmuch.h"
+#endif
+
 #include "mutt_crypt.h"
 
 #include <string.h>
@@ -354,7 +358,11 @@ void mutt_free_header (HEADER **h)
 #ifdef MIXMASTER
   mutt_free_list (&(*h)->chain);
 #endif
-#if defined USE_POP || defined USE_IMAP || defined USE_NNTP
+#ifdef USE_NOTMUCH
+  if ((*h)->free_cb)
+    (*h)->free_cb(*h);
+#endif
+#if defined USE_POP || defined USE_IMAP || defined USE_NNTP || defined USE_NOTMUCH
   FREE (&(*h)->data);
 #endif
   FREE (h);		/* __FREE_CHECKED__ */
@@ -465,6 +473,11 @@ char *_mutt_expand_path (char *s, size_t
 	  strfcpy (p, NONULL (Maildir), sizeof (p));
 	else
 #endif
+#ifdef USE_NOTMUCH
+	if (mx_is_notmuch (NONULL (Maildir)))
+	  strfcpy (p, NONULL (Maildir), sizeof (p));
+	else
+#endif
 	if (Maildir && *Maildir && Maildir[strlen (Maildir) - 1] == '/')
 	  strfcpy (p, NONULL (Maildir), sizeof (p));
 	else
@@ -854,6 +867,11 @@ void mutt_pretty_mailbox (char *s, size_
   }
 #endif
 
+#ifdef USE_NOTMUCH
+  if (scheme == U_NOTMUCH)
+    return;
+#endif
+
   /* if s is an url, only collapse path component */
   if (scheme != U_UNKNOWN)
   {
diff -r dd070f9b9ecd -r b19cab9fe4ad mx.c
--- a/mx.c	Sat Mar 31 14:15:41 2018 +0200
+++ b/mx.c	Sat Mar 31 14:15:43 2018 +0200
@@ -49,6 +49,10 @@
 #include "nntp.h"
 #endif
 
+#ifdef USE_NOTMUCH
+#include "mutt_notmuch.h"
+#endif
+
 #include "buffy.h"
 
 #ifdef USE_DOTLOCK
@@ -96,6 +100,10 @@ struct mx_ops* mx_get_ops (int magic)
     case MUTT_NNTP:
       return &mx_nntp_ops;
 #endif
+#ifdef USE_NOTMUCH
+    case MUTT_NOTMUCH:
+      return &mx_notmuch_ops;
+#endif
     default:
       return NULL;
   }
@@ -402,6 +410,24 @@ int mx_is_nntp (const char *p)
 }
 #endif
 
+#ifdef USE_NOTMUCH
+
+int mx_is_notmuch(const char *p)
+{
+  url_scheme_t scheme;
+
+  if (!p)
+    return 0;
+
+  scheme = url_check_scheme (p);
+  if (scheme == U_NOTMUCH)
+    return 1;
+
+  return 0;
+}
+
+#endif
+
 int mx_get_magic (const char *path)
 {
   struct stat st;
@@ -424,6 +450,11 @@ int mx_get_magic (const char *path)
     return MUTT_NNTP;
 #endif /* USE_NNTP */
 
+#ifdef USE_NOTMUCH
+  if (mx_is_notmuch(path))
+    return MUTT_NOTMUCH;
+#endif
+
   if (stat (path, &st) == -1)
   {
     dprint (1, (debugfile, "mx_get_magic(): unable to stat %s: %s (errno %d).\n",
@@ -1068,6 +1099,10 @@ int mx_close_mailbox (CONTEXT *ctx, int 
   return 0;
 }
 
+#if USE_NOTMUCH
+#include "mutt_notmuch.h"
+#endif
+
 
 /* update a Context structure's internal tables. */
 
@@ -1409,6 +1444,7 @@ int mx_close_message (CONTEXT *ctx, MESS
     FREE (&(*msg)->path);
   }
 
+  FREE (&(*msg)->commited_path);
   FREE (msg);		/* __FREE_CHECKED__ */
   return (r);
 }
diff -r dd070f9b9ecd -r b19cab9fe4ad mx.h
--- a/mx.h	Sat Mar 31 14:15:41 2018 +0200
+++ b/mx.h	Sat Mar 31 14:15:43 2018 +0200
@@ -39,6 +39,7 @@ enum
   MUTT_NNTP,
 #endif
   MUTT_IMAP,
+  MUTT_NOTMUCH,
   MUTT_POP
 #ifdef USE_COMPRESSED
   , MUTT_COMPRESSED
@@ -61,7 +62,24 @@ int mh_check_empty (const char *);
 
 int maildir_check_empty (const char *);
 
-FILE *maildir_open_find_message (const char *, const char *);
+HEADER *maildir_parse_message (int magic, const char *fname, int is_old, HEADER * _h);
+HEADER *maildir_parse_stream (int magic, FILE *f, const char *fname, int is_old, HEADER * _h);
+void maildir_parse_flags (HEADER * h, const char *path);
+int maildir_update_flags (CONTEXT *ctx, HEADER *o, HEADER *n);
+void maildir_flags(char *dest, size_t destlen, HEADER * hdr);
+
+#if USE_HCACHE
+#include <hcache.h>
+int mh_sync_mailbox_message (CONTEXT * ctx, int msgno, header_cache_t *hc);
+#else
+int mh_sync_mailbox_message (CONTEXT * ctx, int msgno);
+#endif
+
+#ifdef USE_NOTMUCH
+int mx_is_notmuch(const char *p);
+#endif
+
+FILE *maildir_open_find_message (const char *, const char *, char **);
 
 int mbox_strict_cmp_headers (const HEADER *, const HEADER *);
 int mutt_reopen_mailbox (CONTEXT *, int *);
diff -r dd070f9b9ecd -r b19cab9fe4ad pattern.c
--- a/pattern.c	Sat Mar 31 14:15:41 2018 +0200
+++ b/pattern.c	Sat Mar 31 14:15:43 2018 +0200
@@ -42,6 +42,10 @@
 #include "imap/imap.h"
 #endif
 
+#ifdef USE_NOTMUCH
+#include "mutt_notmuch.h"
+#endif
+
 static int eat_regexp (pattern_t *pat, BUFFER *, BUFFER *);
 static int eat_date (pattern_t *pat, BUFFER *, BUFFER *);
 static int eat_range (pattern_t *pat, BUFFER *, BUFFER *);
@@ -98,6 +102,9 @@ Flags[] =
   { 'x', MUTT_REFERENCE,		0,		eat_regexp },
   { 'X', MUTT_MIMEATTACH,		0,		eat_range },
   { 'y', MUTT_XLABEL,		0,		eat_regexp },
+#ifdef USE_NOTMUCH
+  { 'Y', MUTT_NOTMUCH_LABEL,	0,		eat_regexp },
+#endif
   { 'z', MUTT_SIZE,		0,		eat_range },
   { '=', MUTT_DUPLICATED,		0,		NULL },
   { '$', MUTT_UNREFERENCED,	0,		NULL },
@@ -1329,6 +1336,13 @@ mutt_pattern_exec (struct pattern_t *pat
      return (pat->not ^ ((h->security & APPLICATION_PGP) && (h->security & PGPKEY)));
     case MUTT_XLABEL:
       return (pat->not ^ (h->env->x_label && patmatch (pat, h->env->x_label) == 0));
+#ifdef USE_NOTMUCH
+    case MUTT_NOTMUCH_LABEL:
+      {
+      char *tags = nm_header_get_tags(h);
+      return (pat->not ^ (tags && patmatch (pat, tags) == 0));
+      }
+#endif
     case MUTT_HORMEL:
       return (pat->not ^ (h->env->spam && h->env->spam->data && patmatch (pat, h->env->spam->data) == 0));
     case MUTT_DUPLICATED:
diff -r dd070f9b9ecd -r b19cab9fe4ad protos.h
--- a/protos.h	Sat Mar 31 14:15:41 2018 +0200
+++ b/protos.h	Sat Mar 31 14:15:43 2018 +0200
@@ -79,6 +79,9 @@ void mutt_generate_boundary (PARAMETER *
 void mutt_delete_parameter (const char *attribute, PARAMETER **p);
 void mutt_set_parameter (const char *, const char *, PARAMETER **);
 
+#ifdef USE_NOTMUCH
+int mutt_parse_virtual_mailboxes (BUFFER *path, BUFFER *s, unsigned long data, BUFFER *err);
+#endif
 
 FILE *mutt_open_read (const char *, pid_t *);
 
@@ -296,6 +299,10 @@ int mutt_check_overwrite (const char *, 
 int mutt_check_traditional_pgp (HEADER *, int *);
 int mutt_command_complete (char *, size_t, int, int);
 int mutt_var_value_complete (char *, size_t, int);
+#if USE_NOTMUCH
+int mutt_nm_query_complete (char *buffer, size_t len, int pos, int numtabs);
+int mutt_nm_tag_complete (char *buffer, size_t len, int pos, int numtabs);
+#endif
 int mutt_complete (char *, size_t);
 int mutt_compose_attachment (BODY *a);
 int mutt_copy_body (FILE *, BODY **, BODY *);
@@ -311,8 +318,10 @@ int mutt_chscmp (const char *s, const ch
 int mutt_parent_message (CONTEXT *, HEADER *, int);
 int mutt_prepare_template(FILE*, CONTEXT *, HEADER *, HEADER *, short);
 int mutt_resend_message (FILE *, CONTEXT *, HEADER *);
-#define mutt_enter_fname(A,B,C,D) _mutt_enter_fname(A,B,C,D,0,NULL,NULL)
-int _mutt_enter_fname (const char *, char *, size_t, int, int, char ***, int *);
+#define mutt_enter_fname(A,B,C,D) _mutt_enter_fname(A,B,C,D,0,NULL,NULL,0)
+#define mutt_enter_fname(A,B,C,D) _mutt_enter_fname(A,B,C,D,0,NULL,NULL,0)
+#define mutt_enter_vfolder(A,B,C,D) _mutt_enter_fname(A,B,C,D,0,NULL,NULL,MUTT_SEL_VFOLDER)
+int _mutt_enter_fname (const char *, char *, size_t, int, int, char ***, int *, int);
 int  mutt_enter_string (char *buf, size_t buflen, int col, int flags);
 int _mutt_enter_string (char *, size_t, int, int, int, char ***, int *, ENTER_STATE *);
 #define mutt_get_field(A,B,C,D) _mutt_get_field(A,B,C,D,0,NULL,NULL)
@@ -377,7 +386,7 @@ int mutt_user_is_recipient (HEADER *);
 void mutt_update_num_postponed (void);
 int mutt_wait_filter (pid_t);
 int mutt_which_case (const char *);
-int mutt_write_fcc (const char *path, HEADER *hdr, const char *msgid, int, char *);
+int mutt_write_fcc (const char *path, HEADER *hdr, const char *msgid, int, char *, char **);
 int mutt_write_mime_body (BODY *, FILE *);
 int mutt_write_mime_header (BODY *, FILE *);
 int mutt_write_one_header (FILE *fp, const char *tag, const char *value, const char *pfx, int wraplen, int flags);
diff -r dd070f9b9ecd -r b19cab9fe4ad send.c
--- a/send.c	Sat Mar 31 14:15:41 2018 +0200
+++ b/send.c	Sat Mar 31 14:15:43 2018 +0200
@@ -54,6 +54,9 @@
 #include "remailer.h"
 #endif
 
+#ifdef USE_NOTMUCH
+#include "mutt_notmuch.h"
+#endif
 
 static void append_signature (FILE *f)
 {
@@ -1250,6 +1253,7 @@ ci_send_message (int flags,		/* send mod
   char *smime_default_key = NULL;
   char *tag = NULL, *err = NULL;
   char *ctype;
+  char *finalpath = NULL;
 
   int rv = -1;
   
@@ -1789,7 +1793,9 @@ main_loop:
       mutt_prepare_envelope (msg->env, 0);
       mutt_env_to_intl (msg->env, NULL, NULL);	/* Handle bad IDNAs the next time. */
 
-      if (!Postponed || mutt_write_fcc (NONULL (Postponed), msg, (cur && (flags & SENDREPLY)) ? cur->env->message_id : NULL, 1, fcc) < 0)
+      if (!Postponed || mutt_write_fcc (NONULL (Postponed), msg,
+	                    (cur && (flags & SENDREPLY)) ?
+			             cur->env->message_id : NULL, 1, fcc, NULL) < 0)
       {
 	msg->content = mutt_remove_multipart (msg->content);
 	decode_descriptions (msg->content);
@@ -1989,7 +1995,7 @@ full_fcc:
        * message was first postponed.
        */
       msg->received = time (NULL);
-      if (mutt_write_fcc (fcc, msg, NULL, 0, NULL) == -1)
+      if (mutt_write_fcc (fcc, msg, NULL, 0, NULL, &finalpath) == -1)
       {
 	/*
 	 * Error writing FCC, we should abort sending.
@@ -2050,6 +2056,7 @@ full_fcc:
       msg->content = mutt_remove_multipart (msg->content);
       decode_descriptions (msg->content);
       mutt_unprepare_envelope (msg->env);
+      FREE(&finalpath);
       goto main_loop;
     }
     else
@@ -2058,13 +2065,18 @@ full_fcc:
       goto cleanup;
     }
   }
-  else if (!option (OPTNOCURSES) && ! (flags & SENDMAILX))
+  else if (!option (OPTNOCURSES) && ! (flags & SENDMAILX)) {
     mutt_message (i != 0 ? _("Sending in background.") :
 #ifdef USE_NNTP
 		  (flags & SENDNEWS) ? _("Article posted.") : _("Mail sent."));
 #else
 		  _("Mail sent."));
 #endif
+#ifdef USE_NOTMUCH
+    if (option(OPTNOTMUCHRECORD))
+      nm_record_message(ctx, finalpath, cur);
+#endif
+  }
 
   if (WithCrypto && (msg->security & ENCRYPT))
     FREE (&pgpkeylist);
@@ -2109,7 +2121,8 @@ cleanup:
   safe_fclose (&tempfp);
   if (! (flags & SENDNOFREEHEADER))
     mutt_free_header (&msg);
-  
+
+  FREE(&finalpath);
   return rv;
 }
 
diff -r dd070f9b9ecd -r b19cab9fe4ad sendlib.c
--- a/sendlib.c	Sat Mar 31 14:15:41 2018 +0200
+++ b/sendlib.c	Sat Mar 31 14:15:43 2018 +0200
@@ -2843,7 +2843,8 @@ static void set_noconv_flags (BODY *b, s
   }
 }
 
-int mutt_write_fcc (const char *path, HEADER *hdr, const char *msgid, int post, char *fcc)
+int mutt_write_fcc (const char *path, HEADER *hdr, const char *msgid,
+		    int post, char *fcc, char **finalpath)
 {
   CONTEXT f;
   MESSAGE *msg;
@@ -3032,6 +3033,8 @@ int mutt_write_fcc (const char *path, HE
 
   if (mx_commit_message (msg, &f) != 0)
     r = -1;
+  else if (finalpath)
+    *finalpath = safe_strdup(msg->commited_path);
   mx_close_message (&f, &msg);
   mx_close_mailbox (&f, NULL);
 
diff -r dd070f9b9ecd -r b19cab9fe4ad sidebar.c
--- a/sidebar.c	Sat Mar 31 14:15:41 2018 +0200
+++ b/sidebar.c	Sat Mar 31 14:15:43 2018 +0200
@@ -27,7 +27,9 @@
 #include "keymap.h"
 #include "mutt_curses.h"
 #include "mutt_menu.h"
+#include "mx.h"
 #include "sort.h"
+#include "sidebar.h"
 
 /* Previous values for some sidebar config */
 static short PreviousSort = SORT_ORDER;  /* sidebar_sort_method */
@@ -54,6 +56,39 @@ static int BotIndex = -1;    /* Last mai
 static int select_next (void);
 
 
+enum {
+	SB_SRC_NONE = 0,
+	SB_SRC_VIRT,
+	SB_SRC_INCOMING
+};
+static int sidebar_source = SB_SRC_NONE;
+
+static BUFFY *
+get_incoming (void)
+{
+	switch (sidebar_source) {
+	case SB_SRC_NONE:
+		sidebar_source = SB_SRC_INCOMING;
+
+#ifdef USE_NOTMUCH
+		if (option (OPTVIRTSPOOLFILE) && VirtIncoming) {
+			sidebar_source = SB_SRC_VIRT;
+			return VirtIncoming;
+		}
+		break;
+	case SB_SRC_VIRT:
+		if (VirtIncoming) {
+			return VirtIncoming;
+		}
+		break;
+#endif
+	case SB_SRC_INCOMING:
+		break;
+	}
+
+	return Incoming;	/* default */
+}
+
 /**
  * cb_format_str - Create the string to show in the sidebar
  * @dest:        Buffer in which to save string
@@ -263,6 +298,9 @@ static int cb_qsort_sbe (const void *a, 
     case SORT_UNREAD:
       result = (b2->msg_unread - b1->msg_unread);
       break;
+    case SORT_DESC:
+      result = mutt_strcmp (b1->desc, b2->desc);
+      break;
     case SORT_FLAGGED:
       result = (b2->msg_flagged - b1->msg_flagged);
       break;
@@ -324,7 +362,7 @@ static void update_entries_visibility (v
  */
 static void unsort_entries (void)
 {
-  BUFFY *cur = Incoming;
+  BUFFY *cur = get_incoming();
   int i = 0, j;
   SBENTRY *tmp;
 
@@ -665,6 +703,12 @@ static void draw_sidebar (int num_rows, 
         safe_strcat (sidebar_folder_name, sfn_len, tmp_folder_name);
       }
     }
+#ifdef USE_NOTMUCH
+    else if (b->magic == MUTT_NOTMUCH)
+    {
+      sidebar_folder_name = b->desc;
+    }
+#endif
     char str[STRING];
     make_sidebar_entry (str, sizeof (str), w, sidebar_folder_name, entry);
     printw ("%s", str);
@@ -695,7 +739,12 @@ void mutt_sb_draw (void)
   if (div_width < 0)
     return;
 
-  if (!Incoming)
+  BUFFY *b;
+  if (Entries == NULL)
+    for (b = get_incoming(); b; b = b->next)
+      mutt_sb_notify_mailbox (b, 1);
+
+  if (!get_incoming())
   {
     fill_empty_space (0, num_rows, div_width, num_cols - div_width);
     return;
@@ -939,7 +988,7 @@ void mutt_sb_set_buffystats (const CONTE
 {
   /* Even if the sidebar's hidden,
    * we should take note of the new data. */
-  BUFFY *b = Incoming;
+  BUFFY *b = get_incoming();
   if (!ctx || !b)
     return;
 
@@ -1016,6 +1065,9 @@ void mutt_sb_notify_mailbox (BUFFY *b, i
   if (!b)
     return;
 
+  if (sidebar_source == SB_SRC_NONE)
+    return;
+
   /* Any new/deleted mailboxes will cause a refresh.  As long as
    * they're valid, our pointers will be updated in prepare_sidebar() */
 
@@ -1066,3 +1118,36 @@ void mutt_sb_notify_mailbox (BUFFY *b, i
 
   mutt_set_current_menu_redraw (REDRAW_SIDEBAR);
 }
+
+/**
+ * mutt_sb_toggle_virtual - Switch between regular and virtual folders
+ */
+void
+mutt_sb_toggle_virtual (void)
+{
+	if (sidebar_source == -1)
+		get_incoming();
+
+#ifdef USE_NOTMUCH
+	if ((sidebar_source == SB_SRC_INCOMING) && VirtIncoming)
+		sidebar_source = SB_SRC_VIRT;
+	else
+#endif
+		sidebar_source = SB_SRC_INCOMING;
+
+	TopIndex = -1;
+	OpnIndex = -1;
+	HilIndex = -1;
+	BotIndex = -1;
+
+	BUFFY *b;
+
+	EntryCount = 0;
+	FREE(&Entries);
+	EntryLen = 0;
+	for (b = get_incoming(); b; b = b->next)
+		mutt_sb_notify_mailbox (b, 1);
+
+	mutt_set_current_menu_redraw (REDRAW_SIDEBAR);
+}
+
diff -r dd070f9b9ecd -r b19cab9fe4ad sidebar.h
--- a/sidebar.h	Sat Mar 31 14:15:41 2018 +0200
+++ b/sidebar.h	Sat Mar 31 14:15:43 2018 +0200
@@ -28,6 +28,7 @@ void         mutt_sb_draw (void);
 const char * mutt_sb_get_highlight (void);
 void         mutt_sb_notify_mailbox (BUFFY *b, int created);
 void         mutt_sb_set_buffystats (const CONTEXT *ctx);
-BUFFY *      mutt_sb_set_open_buffy (void);
+void         mutt_sb_set_open_buffy (void);
+void         mutt_sb_toggle_virtual (void);
 
 #endif /* SIDEBAR_H */
diff -r dd070f9b9ecd -r b19cab9fe4ad status.c
--- a/status.c	Sat Mar 31 14:15:41 2018 +0200
+++ b/status.c	Sat Mar 31 14:15:43 2018 +0200
@@ -27,6 +27,10 @@
 #include "mapping.h"
 #include "mx.h"
 
+#ifdef USE_NOTMUCH
+#include "mutt_notmuch.h"
+#endif
+
 #include <string.h>
 #include <ctype.h>
 #include <unistd.h>
@@ -95,7 +99,14 @@ status_format_str (char *buf, size_t buf
       break;
 
     case 'f':
-      snprintf (fmt, sizeof(fmt), "%%%ss", prefix);
+    {
+#ifdef USE_NOTMUCH
+      char *p;
+      if (Context && Context->magic == MUTT_NOTMUCH &&
+                   (p = nm_get_description(Context)))
+	  strfcpy(tmp, p, sizeof (tmp));
+      else
+#endif
 #ifdef USE_COMPRESSED
       if (Context && Context->compress_info && Context->realpath) {
 	 strfcpy (tmp, Context->realpath, sizeof (tmp));
@@ -109,9 +120,11 @@ status_format_str (char *buf, size_t buf
       }
       else
 	strfcpy (tmp, _("(no mailbox)"), sizeof (tmp));
+
+      snprintf (fmt, sizeof(fmt), "%%%ss", prefix);
       snprintf (buf, buflen, fmt, tmp);
       break;
-
+    }
     case 'F':
       if (!optional)
       {
diff -r dd070f9b9ecd -r b19cab9fe4ad url.c
--- a/url.c	Sat Mar 31 14:15:41 2018 +0200
+++ b/url.c	Sat Mar 31 14:15:43 2018 +0200
@@ -43,12 +43,15 @@ static const struct mapping_t UrlMap[] =
   { "news",	U_NNTP },
   { "snews",	U_NNTPS },
   { "mailto",	U_MAILTO },
+#ifdef USE_NOTMUCH
+  { "notmuch",  U_NOTMUCH },
+#endif
   { "smtp",     U_SMTP },
   { "smtps",    U_SMTPS },
   { NULL,	U_UNKNOWN }
 };
 
-static int url_pct_decode (char *s)
+int url_pct_decode (char *s)
 {
   char *d;
 
diff -r dd070f9b9ecd -r b19cab9fe4ad url.h
--- a/url.h	Sat Mar 31 14:15:41 2018 +0200
+++ b/url.h	Sat Mar 31 14:15:43 2018 +0200
@@ -13,6 +13,9 @@ typedef enum url_scheme
   U_SMTP,
   U_SMTPS,
   U_MAILTO,
+#ifdef USE_NOTMUCH
+  U_NOTMUCH,
+#endif
   U_UNKNOWN
 }
 url_scheme_t;
@@ -36,5 +39,6 @@ int url_parse_file (char *d, const char 
 int url_parse_ciss (ciss_url_t *ciss, char *src);
 int url_ciss_tostring (ciss_url_t* ciss, char* dest, size_t len, int flags);
 int url_parse_mailto (ENVELOPE *e, char **body, const char *src);
+int url_pct_decode (char *s);
 
 #endif
